# 前后端分离博客系统

一共前台和后台两套系统，两套系统的前端工程都用现成的，只需要自己编写这两套系统的后端代码就行了

涉及技术栈：SpringBoot,MybatisPlus,SpringSecurity,EasyExcel,Swagger2,Redis,Echarts,Vue,ElementUI....

## 问题总结

* controller和service，mapper写在不同模块里，修改一个模块，默认关联的是老版本的jar包，最新的代码没更新到

  解决：选择父工程，install重新打包

* Table 'xhr_blog.article' doesn't exist
  
  解决：使用MyBatisPlus，实体类要有对应的@TableName，主键属性要有@TableId

stream流，泛型，反射

## easycode插件提高效率

**下载easycode插件**

* 自动生成与数据库相关的对应entity，service，serviceImpl，mapper，controller
* 支持同时生成生成多张表的代码。每张表有独立的配置信息。

**使用**

idea连接数据库，右击要生成模板的数据表，点击“easycode”

**配置代码模板**

自动创建的类可能有些是多余，有些是欠缺。

可以去：setting->easycode->template那里修改模板，调到自己满意的形式

① entity模板

```java
##导入宏定义
$!{define.vm}

##保存文件（宏定义）
#save("/entity", ".java")

##包路径（宏定义）
#setPackageSuffix("entity")

##自动导入包（全局变量）
$!{autoImport.vm}

import java.io.Serializable;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import com.baomidou.mybatisplus.annotation.TableId;
import com.baomidou.mybatisplus.annotation.TableName;
##表注释（宏定义）
#tableComment("表实体类")
@SuppressWarnings("serial")
@Data
@AllArgsConstructor
@NoArgsConstructor
@TableName("$!{tableInfo.obj.name}")
public class $!{tableInfo.name}  {
#foreach($column in $tableInfo.pkColumn)
    #if(${column.comment})//${column.comment}#end
@TableId
    private $!{tool.getClsNameByFullName($column.type)} $!{column.name};
#end

#foreach($column in $tableInfo.otherColumn)
    #if(${column.comment})//${column.comment}#end

    private $!{tool.getClsNameByFullName($column.type)} $!{column.name};
#end
}

```

② mapper（dao）模板

```java
##导入宏定义
$!{define.vm}

##设置表后缀（宏定义）
#setTableSuffix("Mapper")

##保存文件（宏定义）
#save("/mapper", "Mapper.java")

##包路径（宏定义）
#setPackageSuffix("mapper")

import com.baomidou.mybatisplus.core.mapper.BaseMapper;


##表注释（宏定义）
#tableComment("表数据库访问层")
public interface $!{tableName} extends BaseMapper<$!tableInfo.name> {

}

```

③ service模板

```java
##导入宏定义
$!{define.vm}

##设置表后缀（宏定义）
#setTableSuffix("Service")

##保存文件（宏定义）
#save("/service", "Service.java")

##包路径（宏定义）
#setPackageSuffix("service")

import com.baomidou.mybatisplus.extension.service.IService;


##表注释（宏定义）
#tableComment("表服务接口")
public interface $!{tableName} extends IService<$!tableInfo.name> {

}

```


④ serviceImpl模板

```java
##导入宏定义
$!{define.vm}

##设置表后缀（宏定义）
#setTableSuffix("ServiceImpl")

##保存文件（宏定义）
#save("/service/impl", "ServiceImpl.java")

##包路径（宏定义）
#setPackageSuffix("service.impl")

import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import org.springframework.stereotype.Service;

##表注释（宏定义）
#tableComment("表服务实现类")
@Service("$!tool.firstLowerCase($tableInfo.name)Service")
public class $!{tableName} extends ServiceImpl<$!{tableInfo.name}Mapper, $!{tableInfo.name}> implements $!{tableInfo.name}Service {

}

```

## 创建工程-多模块开发

**思考：提高代码复用性**

两套后端系统的很多内容是可能重复的，如果只是单纯的创建两个后端工程，那么就会有大量的重复代码，并且需要修改的时候也需要修改两次，代码复用性不高。

**创建三个模块**
* 前台系统
* 后台系统
* 公共模块：两套系统共用的代码，配置，依赖可以存放在这里



① 创建父模块

创建一个Maven项目，这个总的父项目的pom.xml内容如下：

  1. groupId，artifactId，packaging，version的信息提供给子模块的<parent>结点来继承
  2. modules标签不用加，创建子模块的时候这里自动会添加上
  3. 父模块的<dependencyManagement>标签就是对这个项目需要的依赖进行版本锁定（统一版本），子模块引入父模块有的依赖时，不用加版本号(相当于子模块继承了父模块的配置信息)
  4. 父模块只需要用到pom.xml。src目录可以删掉的。

~~~~xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.xiaored</groupId>
    <artifactId>XRBlog</artifactId>
    <packaging>pom</packaging>
    <version>1.0-SNAPSHOT</version>
    <modules>
        <module>blog-framework</module>
        <module>blog-admin</module>
        <module>blog-user</module>
    </modules>


    <properties>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        <java.version>1.8</java.version>
    </properties>
    <dependencyManagement>


        <dependencies>
            <!-- SpringBoot的依赖配置-->
            <dependency>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-dependencies</artifactId>
                <version>2.5.0</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
            <!--fastjson依赖-->
            <dependency>
                <groupId>com.alibaba</groupId>
                <artifactId>fastjson</artifactId>
                <version>1.2.33</version>
            </dependency>
            <!--jwt依赖-->
            <dependency>
                <groupId>io.jsonwebtoken</groupId>
                <artifactId>jjwt</artifactId>
                <version>0.9.0</version>
            </dependency>
            <!--mybatisPlus依赖-->
            <dependency>
                <groupId>com.baomidou</groupId>
                <artifactId>mybatis-plus-boot-starter</artifactId>
                <version>3.4.3</version>
            </dependency>

            <!--阿里云OSS-->
            <dependency>
                <groupId>com.aliyun.oss</groupId>
                <artifactId>aliyun-sdk-oss</artifactId>
                <version>3.10.2</version>
            </dependency>


            <dependency>
                <groupId>com.alibaba</groupId>
                <artifactId>easyexcel</artifactId>
                <version>3.0.5</version>
            </dependency>

            <dependency>
                <groupId>io.springfox</groupId>
                <artifactId>springfox-swagger2</artifactId>
                <version>2.9.2</version>
            </dependency>
            <dependency>
                <groupId>io.springfox</groupId>
                <artifactId>springfox-swagger-ui</artifactId>
                <version>2.9.2</version>
            </dependency>
        </dependencies>


    </dependencyManagement>

    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.1</version>
                <configuration>
                    <source>${java.version}</source>
                    <target>${java.version}</target>
                    <encoding>${project.build.sourceEncoding}</encoding>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>
~~~~

②创建Maven子模块：公共部分blog-framework

引入前台后台都要用的依赖，如果后期又有新的，直接引入到这个公共模块中就行

~~~~xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <parent>
        <artifactId>XRBlog</artifactId>
        <groupId>com.xiaored</groupId>
        <version>1.0-SNAPSHOT</version>
    </parent>
    <modelVersion>4.0.0</modelVersion>

    <artifactId>blog-framework</artifactId>

    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <!--lombk-->
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>
        <!--junit-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        <!--SpringSecurity启动器-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-security</artifactId>
        </dependency>
        <!--redis依赖-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-redis</artifactId>
        </dependency>
        <!--fastjson依赖-->
        <dependency>
            <groupId>com.alibaba</groupId>
            <artifactId>fastjson</artifactId>
        </dependency>
        <!--jwt依赖-->
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt</artifactId>
        </dependency>
        <!--mybatisPlus依赖-->
        <dependency>
            <groupId>com.baomidou</groupId>
            <artifactId>mybatis-plus-boot-starter</artifactId>
        </dependency>
        <!--mysql数据库驱动-->
        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
        </dependency>

        <!--阿里云OSS-->
        <dependency>
            <groupId>com.aliyun.oss</groupId>
            <artifactId>aliyun-sdk-oss</artifactId>
        </dependency>

        <!--AOP-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-aop</artifactId>
        </dependency>

        <dependency>
            <groupId>com.alibaba</groupId>
            <artifactId>easyexcel</artifactId>
        </dependency>
        <dependency>
            <groupId>io.springfox</groupId>
            <artifactId>springfox-swagger2</artifactId>
        </dependency>
        <dependency>
            <groupId>io.springfox</groupId>
            <artifactId>springfox-swagger-ui</artifactId>
        </dependency>

    </dependencies>
</project>

~~~~

③创建Maven子模块：博客后台blog-admin

只需引入依赖blog-framework

~~~~xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <parent>
        <artifactId>XRBlog</artifactId>
        <groupId>com.xiaored</groupId>
        <version>1.0-SNAPSHOT</version>
    </parent>
    <modelVersion>4.0.0</modelVersion>

    <artifactId>blog-admin</artifactId>

    <dependencies>
        <dependency>
            <groupId>com.xiaored</groupId>
            <artifactId>blog-framework</artifactId>
            <version>1.0-SNAPSHOT</version>
        </dependency>
    </dependencies>

    <properties>
        <maven.compiler.source>8</maven.compiler.source>
        <maven.compiler.target>8</maven.compiler.target>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    </properties>

</project>
~~~~

④创建Maven子模块：博客前台blog-user

只需引入依赖blog-framework

~~~~xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <parent>
        <artifactId>XRBlog</artifactId>
        <groupId>com.xiaored</groupId>
        <version>1.0-SNAPSHOT</version>
    </parent>
    <modelVersion>4.0.0</modelVersion>

    <artifactId>blog-user</artifactId>

    <dependencies>
        <dependency>
            <groupId>com.xiaored</groupId>
            <artifactId>blog-framework</artifactId>
            <version>1.0-SNAPSHOT</version>
        </dependency>
    </dependencies>

    <properties>
        <maven.compiler.source>8</maven.compiler.source>
        <maven.compiler.target>8</maven.compiler.target>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    </properties>

</project>
~~~~

## 博客前台

### SpringBoot和MybatisPuls整合配置测试

①创建启动类

~~~~java
@SpringBootApplication
@MapperScan("com.xiaored.mapper")
public class XiaoRedBlogApplication {

    public static void main(String[] args) {
        SpringApplication.run(XiaoRedBlogApplication.class,args);
    }
}
~~~~

②创建Resource/application.yml配置文件

~~~~yml
server:
  port: 7777
spring:
  datasource:
    url: jdbc:mysql://localhost:3306/xhr_blog?characterEncoding=utf-8&serverTimezone=Asia/Shanghai
    username: root
    password: cronaldo7
    driver-class-name: com.mysql.cj.jdbc.Driver
  servlet:
    multipart:
      max-file-size: 2MB
      max-request-size: 5MB
mybatis-plus:
  configuration:
    # 日志
    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl
  global-config:
    db-config:
      logic-delete-field: delFlag #删除字段名
      logic-delete-value: 1 #删除为1
      logic-not-delete-value: 0 #未删除为0
      id-type: auto #自增
~~~~

③ SQL语句创建xhr_blog数据库及xhr_article表

​	SQL脚本：前后端分离博客系统\资源\SQL\xhr_article.sql

④ 在**公众模块**创建Article实体以及对应的Mapper，Service 

 Article实体类用easycode模板生成

 注意：类上添加@TableName("xhr_article),主键属性@TableId

 com.xiaored.domain.entity.Article

 ![](img/easycode%E7%94%9F%E6%88%90Article%E5%AE%9E%E4%BD%93%E7%B1%BB.png)

com/xiaored/mapper/ArticleMapper.java

~~~~java
public interface ArticleMapper extends BaseMapper<Article> {


}
~~~~

com/xiaored/service/ArticleService.java

~~~~java
public interface ArticleService extends IService<Article> {
}
~~~~

com/xiaored/service/impl/ArticleServiceImpl.java

~~~~java
@Service
public class ArticleServiceImpl extends ServiceImpl<ArticleMapper, Article> implements ArticleService {

}
~~~~

⑤ 在**前台模块**创建Controller测试一下

~~~~java
@RestController
@RequestMapping("/article")
public class ArticleController {

    @Autowired
    private ArticleService articleService;

    @GetMapping("/list")
    public List<Article> test(){
        return articleService.list();
    }
}
~~~~

### 热门文章列表

#### article表分析

**​通过需求去分析article需要有哪些字段**

id，title，content,create_by,create_time,update_by,update_time肯定要有

* summary：文章摘要
* category_id：文章要分类
* thumbnail：展示到主页上的一个缩略图
* is_top：想要将文章置顶，就置1
* status：标识文章状态，0已发布，1草稿
* view_count：浏览量
* del_flag：对应前台模块application.yml中设置的删除字段，0未删，1已删

#### 需求

要求展示​浏览量前10的文章的标题和浏览量，能让用户点击跳转到具体的文章详情进行浏览。

不能把草稿展示出来，不能把已删除的文章查询出来。

要按照浏览量进行降序排序。

#### 接口设计

见接口文档

#### 基础版本代码实现

①准备工作

在**公共模块**创建统一响应类和响应枚举

com.xiaored.domain.ResponseResult.java

~~~~java
package com.sangeng.domain;

import com.fasterxml.jackson.annotation.JsonInclude;
import com.sangeng.enums.AppHttpCodeEnum;

import java.io.Serializable;

@JsonInclude(JsonInclude.Include.NON_NULL)
public class ResponseResult<T> implements Serializable {
    private Integer code;
    private String msg;
    private T data;

    public ResponseResult() {
        this.code = AppHttpCodeEnum.SUCCESS.getCode();
        this.msg = AppHttpCodeEnum.SUCCESS.getMsg();
    }

    public ResponseResult(Integer code, T data) {
        this.code = code;
        this.data = data;
    }

    public ResponseResult(Integer code, String msg, T data) {
        this.code = code;
        this.msg = msg;
        this.data = data;
    }

    public ResponseResult(Integer code, String msg) {
        this.code = code;
        this.msg = msg;
    }

    public static ResponseResult errorResult(int code, String msg) {
        ResponseResult result = new ResponseResult();
        return result.error(code, msg);
    }
    public static ResponseResult okResult() {
        ResponseResult result = new ResponseResult();
        return result;
    }
    public static ResponseResult okResult(int code, String msg) {
        ResponseResult result = new ResponseResult();
        return result.ok(code, null, msg);
    }

    public static ResponseResult okResult(Object data) {
        ResponseResult result = setAppHttpCodeEnum(AppHttpCodeEnum.SUCCESS, AppHttpCodeEnum.SUCCESS.getMsg());
        if(data!=null) {
            result.setData(data);
        }
        return result;
    }

    public static ResponseResult errorResult(AppHttpCodeEnum enums){
        return setAppHttpCodeEnum(enums,enums.getMsg());
    }

    public static ResponseResult errorResult(AppHttpCodeEnum enums, String msg){
        return setAppHttpCodeEnum(enums,msg);
    }

    public static ResponseResult setAppHttpCodeEnum(AppHttpCodeEnum enums){
        return okResult(enums.getCode(),enums.getMsg());
    }

    private static ResponseResult setAppHttpCodeEnum(AppHttpCodeEnum enums, String msg){
        return okResult(enums.getCode(),msg);
    }

    public ResponseResult<?> error(Integer code, String msg) {
        this.code = code;
        this.msg = msg;
        return this;
    }

    public ResponseResult<?> ok(Integer code, T data) {
        this.code = code;
        this.data = data;
        return this;
    }

    public ResponseResult<?> ok(Integer code, T data, String msg) {
        this.code = code;
        this.data = data;
        this.msg = msg;
        return this;
    }

    public ResponseResult<?> ok(T data) {
        this.data = data;
        return this;
    }

    public Integer getCode() {
        return code;
    }

    public void setCode(Integer code) {
        this.code = code;
    }

    public String getMsg() {
        return msg;
    }

    public void setMsg(String msg) {
        this.msg = msg;
    }

    public T getData() {
        return data;
    }

    public void setData(T data) {
        this.data = data;
    }
}
~~~~

com.sangeng.enums

~~~~java
package com.sangeng.enums;

public enum AppHttpCodeEnum {
    // 成功
    SUCCESS(200,"操作成功"),
    // 登录
    NEED_LOGIN(401,"需要登录后操作"),
    NO_OPERATOR_AUTH(403,"无权限操作"),
    SYSTEM_ERROR(500,"出现错误"),
    USERNAME_EXIST(501,"用户名已存在"),
     PHONENUMBER_EXIST(502,"手机号已存在"), EMAIL_EXIST(503, "邮箱已存在"),
    REQUIRE_USERNAME(504, "必需填写用户名"),
    LOGIN_ERROR(505,"用户名或密码错误");
    int code;
    String msg;

    AppHttpCodeEnum(int code, String errorMessage){
        this.code = code;
        this.msg = errorMessage;
    }

    public int getCode() {
        return code;
    }

    public String getMsg() {
        return msg;
    }
}
~~~~

② 代码实现

**前台模块**的controller层

~~~~java
@RestController
@RequestMapping("/article")
public class ArticleController {

    @Autowired
    private ArticleService articleService;
    
    @GetMapping("/hotArticleList")
    public ResponseResult hotArticleList(){

        ResponseResult result =  articleService.hotArticleList();
        return result;
    }
}
~~~~

**公共模块**的service层

~~~~java
public interface ArticleService extends IService<Article> {
    ResponseResult hotArticleList();
}
~~~~

~~~~java
@Service
public class ArticleServiceImpl extends ServiceImpl<ArticleMapper, Article> implements ArticleService {
    @Override
    public ResponseResult hotArticleList() {
        //查询热门文章 封装成ResponseResult返回
        LambdaQueryWrapper<Article> queryWrapper = new LambdaQueryWrapper<>();
        //必须是正式文章
        queryWrapper.eq(Article::getStatus,0);
        //不用关心逻辑删除字段：yml里配置过了
        
        //按照浏览量进行排序
        queryWrapper.orderByDesc(Article::getViewCount);
        //最多只查询10条
        Page<Article> page = new Page(1,10);//当前在第一页，每页大小为10
        page(page,queryWrapper);

        List<Article> articles = page.getRecords();
        return ResponseResult.okResult(articles);//用ResponseResult的静态方法okResult
    }
}
~~~~

③ 前端联调

在前端工程目录下cmd后，运行以下两个指令

``` bash
# install dependencies
npm install

# serve with hot reload at localhost:8080
npm run dev
```

④ 解决跨域问题

~~~~java
@Configuration
public class WebConfig implements WebMvcConfigurer {

    @Override
    public void addCorsMappings(CorsRegistry registry) {
      // 设置允许跨域的路径
        registry.addMapping("/**")
                // 设置允许跨域请求的域名
                .allowedOriginPatterns("*")
                // 是否允许cookie
                .allowCredentials(true)
                // 设置允许的请求方式
                .allowedMethods("GET", "POST", "DELETE", "PUT")
                // 设置允许的header属性
                .allowedHeaders("*")
                // 跨域允许时间
                .maxAge(3600);
    }

}
~~~~

测试的时候把SpringSecurity依赖注释掉

#### 使用VO优化

目前的响应格式其实是不符合接口文档的标准的，返回了太多字段。这是因为查询出来的结果是Article来封装的，Article中字段比较多。

在项目中是不会直接返回一个实体类的，而是用VO来接受查询出来的结果。一个接口对应一个VO，这样即使接口响应字段要修改也只要改VO即可。

在**公共模块**创建com/xiaored/vo/HotArticleVo.java

~~~~java
@Data
@NoArgsConstructor
@AllArgsConstructor
public class HotArticleVo {
    private Long id;
    //标题
    private String title;

    //访问量
    private Long viewCount;
}
~~~~

优化hotArticleList()，给ReponseResult传`List<HotArticleVo>`

~~~~java
@Service
public class ArticleServiceImpl extends ServiceImpl<ArticleMapper, Article> implements ArticleService {

    @Override
    public ResponseResult hotArticleList() {
        //查询热门文章 封装成ResponseResult返回
        LambdaQueryWrapper<Article> queryWrapper = new LambdaQueryWrapper<>();
        //必须是正式文章
        queryWrapper.eq(Article::getStatus,0);
        //按照浏览量进行排序
        queryWrapper.orderByDesc(Article::getViewCount);
        //最多只查询10条
        Page<Article> page = new Page(1,10);
        page(page,queryWrapper);

        List<Article> articles = page.getRecords();
        //bean拷贝
        List<HotArticleVo> articleVos = new ArrayList<>();
        for (Article article : articles) {
            HotArticleVo vo = new HotArticleVo();//创建vo
            BeanUtils.copyProperties(article,vo);//将Article中和vo属性名一样的属性复制给vo
            articleVos.add(vo);//将vo添加到List中
        }

        return ResponseResult.okResult(articleVos);
    }
}
~~~~

#### 字面值处理

实际项目中都不允许直接在代码中使用字面值。都需要定义成常量来使用。这种方式有利于提高代码的可维护性。

**解决方法：创建一个常量类**

在**公共模块**创建com/xiaored/constants/SystemConstants.java

~~~~java
public class SystemConstants
{
    /**
     *  文章是草稿
     */
    public static final int ARTICLE_STATUS_DRAFT = 1;
    /**
     *  文章是正常分布状态
     */
    public static final int ARTICLE_STATUS_NORMAL = 0;
}
~~~~

优化hotArticleList()，使用定义好的常量

~~~~java
@Service
public class ArticleServiceImpl extends ServiceImpl<ArticleMapper, Article> implements ArticleService {

    @Override
    public ResponseResult hotArticleList() {
        //查询热门文章 封装成ResponseResult返回
        LambdaQueryWrapper<Article> queryWrapper = new LambdaQueryWrapper<>();
        //必须是正式文章，用定义好的常量
        queryWrapper.eq(Article::getStatus, SystemConstants.ARTICLE_STATUS_NORMAL);
        //按照浏览量进行排序
        queryWrapper.orderByDesc(Article::getViewCount);
        //最多只查询10条
        Page<Article> page = new Page(1,10);
        page(page,queryWrapper);

        List<Article> articles = page.getRecords();
        //bean拷贝
        List<HotArticleVo> articleVos = new ArrayList<>();
        for (Article article : articles) {
            HotArticleVo vo = new HotArticleVo();//创建vo
            BeanUtils.copyProperties(article,vo);//将Article中和vo属性名一样的属性复制给vo
            articleVos.add(vo);//将vo添加到List中
        }

        return ResponseResult.okResult(articleVos);
    }
}
~~~~

### Bean拷贝工具类封装（搞不懂，javase泛型，反射要补补）

在**公共模块**创建com/xiaored/utils/BeanCopyUtils.java

~~~~java
public class BeanCopyUtils {

    private BeanCopyUtils() {
    }

    public static <V> V copyBean(Object source,Class<V> clazz) {
        //创建目标对象
        V result = null;
        try {
            result = clazz.newInstance();
            //实现属性copy
            BeanUtils.copyProperties(source, result);
        } catch (Exception e) {
            e.printStackTrace();
        }
        //返回结果
        return result;
    }
    public static <O,V> List<V> copyBeanList(List<O> list,Class<V> clazz){
        return list.stream()
                .map(o -> copyBean(o, clazz))
                .collect(Collectors.toList());
    }
}
~~~~

用这个工具类优化hotArticleList()的bean拷贝

~~~~java
@Service
public class ArticleServiceImpl extends ServiceImpl<ArticleMapper, Article> implements ArticleService {

    @Override
    public ResponseResult hotArticleList() {
        //查询热门文章 封装成ResponseResult返回
        LambdaQueryWrapper<Article> queryWrapper = new LambdaQueryWrapper<>();
        //必须是正式文章
        queryWrapper.eq(Article::getStatus, SystemConstants.ARTICLE_STATUS_NORMAL);
        //按照浏览量进行排序
        queryWrapper.orderByDesc(Article::getViewCount);
        //最多只查询10条
        Page<Article> page = new Page(1,10);
        page(page,queryWrapper);

        List<Article> articles = page.getRecords();
        //bean拷贝
        /*List<HotArticleVo> articleVos = new ArrayList<>();
        for (Article article : articles) {
            HotArticleVo vo = new HotArticleVo();//创建vo
            BeanUtils.copyProperties(article,vo);//将Article中和vo属性名一样的属性复制给vo
            articleVos.add(vo);//将vo添加到List中
        }*/
        List<HotArticleVo> vs= BeanCopyUtils.copyBeanList(articles, HotArticleVo.class);
        return ResponseResult.okResult(vs);
    }
}
~~~~

### 分类列表

#### 分类表分析

建表SQL及初始化数据见：前后端分离博客系统\资源\SQL\xhr_category.sql

通过需求去分析需要有哪些字段。

id,name,create_by,create_time,update_by,update_time,del_flag肯定要有

* pid：表示父分类的id
* description：描述信息
* status：表示分类的状态（可以在后台禁用对应的分类）

#### 需求

![image-20220202111056036](img/image-20220202111056036-16437714601701.png)

页面上需要展示分类列表，用户可以点击具体的分类查看该分类下的文章列表。

注意： 

①要求只展示有发布正式文章的分类 

②必须是正常状态的分类

#### 接口设计

见接口文档

#### 代码实现

严禁三张表以上的联查（必须分步查）

用easycode在**公共模块**生成Category，CategoryService，CategoryServiceImpl，CategoryMapper

**前台模块**创建com/xiaored/controller/CategoryController.java

~~~~java
@RestController
@RequestMapping("/category")
public class CategoryController {

    @Autowired
    private CategoryService categoryService;

    @GetMapping("/getCategoryList")
    public ResponseResult getCategoryList(){
       return categoryService.getCategoryList();
    }
}    
~~~~

**公共模块**

编写service层

~~~~java
public interface CategoryService extends IService<Category> {


    ResponseResult getCategoryList();

}
~~~~

~~~~java
@Service("categoryService")
public class CategoryServiceImpl extends ServiceImpl<CategoryMapper, Category> implements CategoryService {

    @Autowired
    private ArticleService articleService;

    @Override
    public ResponseResult getCategoryList() {
        //查询文章表  状态为已发布的文章
        LambdaQueryWrapper<Article> articleWrapper = new LambdaQueryWrapper<>();
        articleWrapper.eq(Article::getStatus,SystemConstants.ARTICLE_STATUS_NORMAL);
        List<Article> articleList = articleService.list(articleWrapper);
        //获取文章的分类id，并且去重
        Set<Long> categoryIds = articleList.stream()
                .map(article -> article.getCategoryId())
                .collect(Collectors.toSet());

        //查询分类表
        List<Category> categories = listByIds(categoryIds);
        categories = categories.stream().
                filter(category -> SystemConstants.STATUS_NORMAL.equals(category.getStatus()))
                .collect(Collectors.toList());
        //封装vo
        List<CategoryVo> categoryVos = BeanCopyUtils.copyBeanList(categories, CategoryVo.class);

        return ResponseResult.okResult(categoryVos);
    }
}

~~~~

常量类添加一个常量

```java
public static final String STATUS_NORMAL = "0";
```

创建com/xiaored/vo/CategoryVo.java

```java
@Data
@NoArgsConstructor
@AllArgsConstructor
public class CategoryVo {
    private Long id;
    private String name;
}
```

### 分页查询文章列表

#### 需求

在首页和分类页面都需要查询文章列表。

首页：查询所有的文章

分类页面：查询对应分类下的文章

要求：

①只能查询正式发布的文章 

②置顶的文章要显示在最前面 

③展示标题，发布时间，浏览量，概述，缩略图，所属分类

④数据量大，设计分页接口

#### 接口设计

见文档，传参：分类id，页码，页码大小

#### 代码实现

**前台模块**

在ArticleController中添加文章列表的响应方法

~~~~java
    @GetMapping("/articleList")
    public ResponseResult articleList(Integer pageNum,Integer pageSize,Long categoryId){
        return articleService.articleList(pageNum,pageSize,categoryId);
    }
~~~~

**公共模块**

创建com/xiaored/config/MbatisPlusConfig.java

使MybatisPlus支持分页配置

~~~~java
@Configuration
public class MbatisPlusConfig {

    /**
     * 3.4.0之后版本
     * @return
     */
    @Bean
    public MybatisPlusInterceptor mybatisPlusInterceptor(){
        MybatisPlusInterceptor mybatisPlusInterceptor = new MybatisPlusInterceptor();
        mybatisPlusInterceptor.addInnerInterceptor(new PaginationInnerInterceptor());
        return mybatisPlusInterceptor;
    }
}
~~~~

在ArticleService中添加`articleList`方法

~~~~java
ResponseResult articleList(Integer pageNum, Integer pageSize, Long categoryId);
~~~~

在ArticleServiceImpl中实现`articleList`方法

注：分页接口要进行两次封装，对实体类进行vo，然后将这个vo按照page再vo

~~~~java

@Service
public class ArticleServiceImpl extends ServiceImpl<ArticleMapper, Article> implements ArticleService {

    @Autowired
    private CategoryService categoryService;

    @Override
    public ResponseResult hotArticleList() {
        //查询热门文章 封装成ResponseResult返回
        LambdaQueryWrapper<Article> queryWrapper = new LambdaQueryWrapper<>();
        //必须是正式文章
        queryWrapper.eq(Article::getStatus, SystemConstants.ARTICLE_STATUS_NORMAL);
        //按照浏览量进行排序
        queryWrapper.orderByDesc(Article::getViewCount);
        //最多只查询10条
        Page<Article> page = new Page(1,10);
        page(page,queryWrapper);

        List<Article> articles = page.getRecords();
        //bean拷贝
        List<HotArticleVo> vs = BeanCopyUtils.copyBeanList(articles, HotArticleVo.class);
        return ResponseResult.okResult(vs);
    }

    @Override
    public ResponseResult articleList(Integer pageNum, Integer pageSize, Long categoryId) {
        //查询条件
        LambdaQueryWrapper<Article> lambdaQueryWrapper = new LambdaQueryWrapper<>();
        // 如果 有categoryId 就要 查询时要和传入的相同
        //第一个参数：一个bool表达式，要求前端传来了categoryId并且大于0。如果这个参数为true，就会把对第二，三个参数的判断加到sql语句中
        lambdaQueryWrapper.eq(Objects.nonNull(categoryId)&&categoryId>0 ,Article::getCategoryId,categoryId);
        // 状态是正式发布的
        lambdaQueryWrapper.eq(Article::getStatus,SystemConstants.ARTICLE_STATUS_NORMAL);
        // 按isTop进行降序
        lambdaQueryWrapper.orderByDesc(Article::getIsTop);

        //分页查询
        Page<Article> page = new Page<>(pageNum,pageSize);
        page(page,lambdaQueryWrapper);

        List<Article> articles = page.getRecords();
        //分类名称问题解决（Stream流）查询categoryName
        articles.stream()
                //这么写的话，Article类加上@Accessors(chain=true)
                .map(article -> article.setCategoryName(categoryService.getById(article.getCategoryId()).getName()))
                .collect(Collectors.toList());

        //分类名称问题解决（普通循环方式）：按articleId去查询articleName进行设置
//        for (Article article : articles) {
//            Category category = categoryService.getById(article.getCategoryId());
//            article.setCategoryName(category.getName());
//        }

        //封装查询结果
        List<ArticleListVo> articleListVos = BeanCopyUtils.copyBeanList(page.getRecords(), ArticleListVo.class);

        PageVo pageVo = new PageVo(articleListVos,page.getTotal());
        return ResponseResult.okResult(pageVo);
    }
}
~~~~

创建com/xiaored/vo/PageVo.java

~~~~java
@Data
@NoArgsConstructor
@AllArgsConstructor
public class PageVo {
    private List rows;
    private Long total;
}

~~~~

创建com/xiaored/vo/ArticleListVo.java

~~~~java
@Data
@NoArgsConstructor
@AllArgsConstructor
public class ArticleListVo {

    private Long id;
    //标题
    private String title;
    //文章摘要
    private String summary;
    //所属分类名
    private String categoryName;
    //缩略图
    private String thumbnail;
    //访问量
    private Long viewCount;

    private Date createTime;
}
~~~~

Article实体类

 * 添加`@Accessors(chain=true)`

 * 增加一个字段
~~~~java
    @TableField(exist = false)//表示这个字段在数据表中是不存在的
    private String categoryName;
~~~~



#### FastJson配置

Date类型默认用JackSon来进行Json转换，格式和性能不是很好

使用FastJson来配置时间的Json转换

在com/xiaored/config/WebConfig.java添加以下内容

~~~~java
    //用来创建FastJsonHttpMessageConverter
    @Bean//使用@Bean注入fastJsonHttpMessageConvert
    public HttpMessageConverter fastJsonHttpMessageConverters() {
        //1.需要定义一个Convert转换消息的对象
        FastJsonHttpMessageConverter fastConverter = new FastJsonHttpMessageConverter();
        FastJsonConfig fastJsonConfig = new FastJsonConfig();
        fastJsonConfig.setSerializerFeatures(SerializerFeature.PrettyFormat);
        fastJsonConfig.setDateFormat("yyyy-MM-dd HH:mm:ss");
		
        SerializeConfig.globalInstance.put(Long.class, ToStringSerializer.instance);

        fastJsonConfig.setSerializeConfig(SerializeConfig.globalInstance);
        fastConverter.setFastJsonConfig(fastJsonConfig);
        HttpMessageConverter<?> converter = fastConverter;
        return converter;
    }

    //配置Json转换器，参数List的元素类型是HttpMessageConverter
    @Override
    public void configureMessageConverters(List<HttpMessageConverter<?>> converters) {
        converters.add(fastJsonHttpMessageConverters());
    }
~~~~

### 文章详情接口

#### 需求

要求在文章列表点击阅读全文时能够跳转到文章详情页面，可以让用户阅读文章正文。

要求：①要在文章详情中展示其分类名

#### 接口设计

| 请求方式 | 请求路径      |
| -------- | ------------- |
| Get      | /article/{id} |

响应格式：

~~~~json
{
  "code": 200,
  "data": {
    "categoryId": "1",
    "categoryName": "java",
    "content": "内容",
    "createTime": "2022-01-23 23:20:11",
    "id": "1",
    "isComment": "0",
    "title": "SpringSecurity从入门到精通",
    "viewCount": "114"
  },
  "msg": "操作成功"
}
~~~~

#### 代码实现

**前台模块**

ArticleController中新增

~~~~java
    @GetMapping("/{id}")
    public ResponseResult getArticleDetail(@PathVariable("id") Long id){
        return articleService.getArticleDetail(id);
    }
~~~~

**公共模块**

Service

~~~~java
ResponseResult getArticleDetail(Long id);
~~~~

ServiceImpl

~~~~java
    @Override
    public ResponseResult getArticleDetail(Long id) {
        //根据id查询文章
        Article article = getById(id);
        //转换成VO
        ArticleDetailVo articleDetailVo = BeanCopyUtils.copyBean(article, ArticleDetailVo.class);
        //根据分类id查询分类名
        Long categoryId = articleDetailVo.getCategoryId();
        Category category = categoryService.getById(categoryId);
        if(category!=null){//多一层判断，避免空指针
            articleDetailVo.setCategoryName(category.getName());
        }
        //封装响应返回
        return ResponseResult.okResult(articleDetailVo);
    }
~~~~

创建com/xiaored/vo/ArticleDetailVo.java

```java
@Data
@NoArgsConstructor
@AllArgsConstructor
public class ArticleDetailVo {

    private Long id;
    //标题
    private String title;
    //文章摘要
    private String summary;
    //所属分类名id
    private Long categoryId;
    //所属分类名
    private String categoryName;
    //缩略图
    private String thumbnail;
    //文章内容
    private String content;
    //访问量
    private Long viewCount;

    private Date createTime;
}
```

### 友联查询

#### 友链表分析

建表SQL及初始化数据见：\前后端分离博客系统\资源\SQL\xhr_link.sql

通过需求去分析需要有哪些字段。

id,name,logo,description，create_by,create_time,update_by,update_time,del_flag肯定要有

* adress：网站地址
* status：审核状态（0审核通过，1审核未通过，2未审核）


#### 需求

发布的评论如果是以下格式：

>网站名称: 三更博客
网站地址: https://www.baidu.com
网站描述: 百度你懂的
网站logo: https://www.sg.com/1.png

那么后台管理员可以将这个网站添加为友链（但是要审核）

在友链页面要查询出所有的审核通过的友链。

#### 接口设计

友链页面展示审核通过的友链，要包含网站名称，网站描述，网站logo，网站地址（点击即可跳转到那里）

| 请求方式 | 请求路径         |
| -------- | ---------------- |
| Get      | /link/getAllLink |

响应格式：

~~~~json
{
  "code": 200,
  "data": [
    {
      "address": "https://www.baidu.com",
      "description": "sda",
      "id": "1",
      "logo": "图片url1",
      "name": "sda"
    },
    {
      "address": "https://www.qq.com",
      "description": "dada",
      "id": "2",
      "logo": "图片url2",
      "name": "sda"
    }
  ],
  "msg": "操作成功"
}
~~~~

#### 代码实现

由于友链比较少，所以不用设计为分页查询

**前台模块**

创建com/xiaored/controller/LinkController.java

~~~~java
@RestController
@RequestMapping("/link")
public class LinkController {

    @Autowired
    private LinkService linkService;

    @GetMapping("/getAllLink")
    public ResponseResult getAllLink(){
        return linkService.getAllLink();
    }
}

~~~~

**公共模块**

用easycode生成xhr_link数据表的entity，mapper，service，serviceImpl

Service

~~~~java
public interface LinkService extends IService<Link> {

    ResponseResult getAllLink();
}


~~~~

ServiceImpl

~~~~java
@Service("linkService")
public class LinkServiceImpl extends ServiceImpl<LinkMapper, Link> implements LinkService {

    @Override
    public ResponseResult getAllLink() {
        //查询所有审核通过的
        LambdaQueryWrapper<Link> queryWrapper = new LambdaQueryWrapper<>();
        queryWrapper.eq(Link::getStatus, SystemConstants.LINK_STATUS_NORMAL);
        List<Link> links = list(queryWrapper);
        //转换成vo
        List<LinkVo> linkVos = BeanCopyUtils.copyBeanList(links, LinkVo.class);
        //封装返回
        return ResponseResult.okResult(linkVos);
    }
}

~~~~

创建com/xiaored/vo/LinkVo.java

```java
@Data
@NoArgsConstructor
@AllArgsConstructor
public class LinkVo {
    
    private Long id;
    
    private String name;

    private String logo;

    private String description;
    //网站地址
    private String address;
}
```

SystemConstants类添加常量

~~~~java
    /**
     * 友链状态为审核通过
     */
    public static final String  LINK_STATUS_NORMAL = "0";
~~~~

### 登录功能实现（最难的部分）

前台和后台的认证授权统一都使用SpringSecurity安全框架来实现。

#### 需求

需要实现登录功能

有些功能必须登录后才能使用，未登录状态是不能使用的。

#### 接口设计

| 请求方式 | 请求路径 |
| -------- | -------- |
| POST     | /login   |

请求体：

~~~~json
{
    "userName":"sg",
    "password":"1234"
}
~~~~

响应格式：

~~~~json
{
    "code": 200,
    "data": {
        "token": "eyJhbGciOiJIUzI1NiJ9.eyJqdGkiOiI0ODBmOThmYmJkNmI0NjM0OWUyZjY2NTM0NGNjZWY2NSIsInN1YiI6IjEiLCJpc3MiOiJzZyIsImlhdCI6MTY0Mzg3NDMxNiwiZXhwIjoxNjQzOTYwNzE2fQ.ldLBUvNIxQCGemkCoMgT_0YsjsWndTg5tqfJb77pabk",
        "userInfo": {
            "avatar": "https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fi0.hdslb.com%2Fbfs%2Farticle%2F3bf9c263bc0f2ac5c3a7feb9e218d07475573ec8.gi",
            "email": "23412332@qq.com",
            "id": 1,
            "nickName": "sg333",
            "sex": "1"
        }
    },
    "msg": "操作成功"
}
~~~~

#### 表分析

建表SQL及初始化数据见：前后端分离博客系统\资源\SQL\xhr_user.sql

id,user_name,password,sex,create_by,create_time,update_by,update_time,del_flag肯定要有

* nick_name：昵称
* type：用户类型（0代表普通用户，1代表管理员）
* status：账号状态（0正常 1停用）',
* email： 邮箱
* phonenumber：手机号
* avatar：头像

#### 思路分析

**登录**

​①自定义登录接口controller  

绕过UsernamePasswordAuthenticationFilter，将前端提交的用户名和密码给到controller，在controller中​调用ProviderManager的方法进行认证。如果认证通过生成jwt，然后用userid作为key，用户信息作为value存入redis。（在校验的时候就可以从redis中拿，减小数据库的压力）

​②自定义UserDetailsService，实现loadUserByUsername方法
  1. 从数据库查询用户信息（登录功能）
  2. 如果查到，就再去查询对应的权限信息（授权功能）
  3. 封装成UserDetails对象返回（这要求再去创建一个UserDetails的实现类）

**校验**

​①定义Jwt认证过滤器
  1. ​获取token
  2. ​解析token获取其中的userid
  3. ​从redis中获取用户信息
  4. 封装Authentication对象​存入SecurityContextHolder

#### 准备工作

①添加依赖

注意放开Security依赖的注释

~~~~xml
        <!--redis依赖-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-redis</artifactId>
        </dependency>
        <!--fastjson依赖-->
        <dependency>
            <groupId>com.alibaba</groupId>
            <artifactId>fastjson</artifactId>
            <version>1.2.33</version>
        </dependency>
        <!--jwt依赖-->
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt</artifactId>
            <version>0.9.0</version>
        </dependency>
~~~~

②工具类和相关配置类

`前后端分离博客系统\资源\登录功能所需资源`中的配置类和工具类分别添加到**公共模块**的config包和utils包中

#### 登录接口代码实现

##### BlogLoginController

~~~~java
@RestController
public class BlogLoginController {
    @Autowired
    private BlogLoginService blogLoginService;

    @PostMapping("/login")
    public ResponseResult login(@RequestBody User user){
        return blogLoginService.login(user);
    }
}
~~~~

##### BlogLoginService

~~~~java
public interface BlogLoginService {
    ResponseResult login(User user);
}
~~~~

##### SecurityConfig

**注意：这个是添加在前台模块**

这个和后台系统不通用

~~~~java
@Configuration
public class SecurityConfig extends WebSecurityConfigurerAdapter {

    @Bean
    public PasswordEncoder passwordEncoder(){
        return new BCryptPasswordEncoder();
    }
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
                //关闭csrf
                .csrf().disable()
                //不通过Session获取SecurityContext
                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)
                .and()
                .authorizeRequests()
                // 对于登录接口 允许匿名访问
                .antMatchers("/login").anonymous()
                // 除上面外的所有请求全部不需要认证即可访问
                .anyRequest().permitAll();


        http.logout().disable();
        //允许跨域
        http.cors();
    }
    @Override
    @Bean
    public AuthenticationManager authenticationManagerBean() throws Exception {
        return super.authenticationManagerBean();
    }
}
~~~~

##### BlogLoginServiceImpl 

~~~~java

@Service
public class BlogLoginServiceImpl implements BlogLoginService {

    @Autowired
    private AuthenticationManager authenticationManager;

    @Autowired
    private RedisCache redisCache;

    @Override
    public ResponseResult login(User user) {
        UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(user.getUserName(),user.getPassword());
        Authentication authenticate = authenticationManager.authenticate(authenticationToken);
        //判断是否认证通过
        if(Objects.isNull(authenticate)){
            throw new RuntimeException("用户名或密码错误");
        }
        //获取userid 生成token
        LoginUser loginUser = (LoginUser) authenticate.getPrincipal();
        String userId = loginUser.getUser().getId().toString();
        String jwt = JwtUtil.createJWT(userId);
        //把用户信息存入redis
        redisCache.setCacheObject("bloglogin:"+userId,loginUser);

        //把token和userinfo封装 返回
        //把User转换成UserInfoVo
        UserInfoVo userInfoVo = BeanCopyUtils.copyBean(loginUser.getUser(), UserInfoVo.class);
        BlogUserLoginVo vo = new BlogUserLoginVo(jwt,userInfoVo);
        return ResponseResult.okResult(vo);
    }
}
~~~~



##### UserDetailServiceImpl

**放在公共模块中**

~~~~java
@Service
public class UserDetailsServiceImpl implements UserDetailsService {

    @Autowired
    private UserMapper userMapper;

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        //根据用户名查询用户信息
        LambdaQueryWrapper<User> queryWrapper = new LambdaQueryWrapper<>();
        queryWrapper.eq(User::getUserName,username);
        User user = userMapper.selectOne(queryWrapper);
        //判断是否查到用户  如果没查到抛出异常
        if(Objects.isNull(user)){
            throw new RuntimeException("用户不存在");
        }
        //返回用户信息
        // TODO 查询权限信息封装
        return new LoginUser(user);
    }
}
~~~~

##### LoginUser

~~~~java
@Data
@AllArgsConstructor
@NoArgsConstructor
public class LoginUser implements UserDetails {

    private User user;


    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {
        return null;
    }

    @Override
    public String getPassword() {
        return user.getPassword();
    }

    @Override
    public String getUsername() {
        return user.getUserName();
    }

    @Override
    public boolean isAccountNonExpired() {
        return true;
    }

    @Override
    public boolean isAccountNonLocked() {
        return true;
    }

    @Override
    public boolean isCredentialsNonExpired() {
        return true;
    }

    @Override
    public boolean isEnabled() {
        return true;
    }
}

~~~~

##### BlogUserLoginVo

~~~~java
@Data
@NoArgsConstructor
@AllArgsConstructor
public class BlogUserLoginVo {

    private String token;
    private UserInfoVo userInfo;
}
~~~~

##### UserInfoVo

~~~~java
@Data
@Accessors(chain = true)
public class UserInfoVo {
    private Long id;

    private String nickName;

    private String avatar;

    private String sex;

    private String email;
}
~~~~


#### 登录校验过滤器代码实现

##### 思路

​①定义Jwt认证过滤器
  1. ​获取token
  2. ​解析token获取其中的userid
  3. ​从redis中获取用户信息
  4. 封装Authentication对象​存入SecurityContextHolder

##### JwtAuthenticationTokenFilter

过滤器不通用（前后台Redius的key是不同的），添加到**前台模块**

创建com/xiaored/filter/JwtAuthenticationTokenFilter.java

~~~~java
@Component
public class JwtAuthenticationTokenFilter extends OncePerRequestFilter {

    @Autowired
    private RedisCache redisCache;

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {
        //获取请求头中的token
        String token = request.getHeader("token");
        if(!StringUtils.hasText(token)){
            //说明该接口不需要登录  直接放行
            filterChain.doFilter(request, response);
            return;
        }
        //解析获取userid
        Claims claims = null;
        try {
            claims = JwtUtil.parseJWT(token);
        } catch (Exception e) {
            e.printStackTrace();
            //token超时  token非法
            //响应告诉前端需要重新登录
            ResponseResult result = ResponseResult.errorResult(AppHttpCodeEnum.NEED_LOGIN);
            WebUtils.renderString(response, JSON.toJSONString(result));
            return;
        }
        String userId = claims.getSubject();
        //从redis中获取用户信息
        LoginUser loginUser = redisCache.getCacheObject("bloglogin:" + userId);
        //如果获取不到
        if(Objects.isNull(loginUser)){
            //说明登录过期  提示重新登录
            ResponseResult result = ResponseResult.errorResult(AppHttpCodeEnum.NEED_LOGIN);
            WebUtils.renderString(response, JSON.toJSONString(result));
            return;
        }
        //存入SecurityContextHolder
        UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(loginUser,null,null);
        SecurityContextHolder.getContext().setAuthentication(authenticationToken);

        filterChain.doFilter(request, response);
    }


}
~~~~

##### SecurityConfig

* 注入JwtAuthenticationTokenFilter
* 把jwtAuthenticationTokenFilter添加到SpringSecurity的过滤器链中

~~~~java
@Configuration
public class SecurityConfig extends WebSecurityConfigurerAdapter {

    @Override
    @Bean
    public AuthenticationManager authenticationManagerBean() throws Exception {
        return super.authenticationManagerBean();
    }

    @Autowired
    private JwtAuthenticationTokenFilter jwtAuthenticationTokenFilter;

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
                //关闭csrf
                .csrf().disable()
                //不通过Session获取SecurityContext
                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)
                .and()
                .authorizeRequests()
                // 对于登录接口 允许匿名访问
                .antMatchers("/login").anonymous()
                //jwt过滤器测试用，如果测试没有问题吧这里删除了
                .antMatchers("/link/getAllLink").authenticated()
                // 除上面外的所有请求全部不需要认证即可访问
                .anyRequest().permitAll();


        http.logout().disable();
        //把jwtAuthenticationTokenFilter添加到SpringSecurity的过滤器链中
        http.addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class);
        //允许跨域
        http.cors();
    }

    @Bean
    public PasswordEncoder passwordEncoder(){
        return new BCryptPasswordEncoder();
    }
}
~~~~

### 认证授权失败处理

目前项目在认证出错或者权限不足的时候响应回来的Json是Security的异常处理结果。但是这个响应的格式肯定是不符合项目的接口规范的。

所以需要自定义异常处理。

AuthenticationEntryPoint 认证失败处理器

AccessDeniedHandler 授权失败处理器

**公共模块**

com/xiaored/handler/security/AuthenticationEntryPointImpl.java

~~~~java
@Component
public class AuthenticationEntryPointImpl implements AuthenticationEntryPoint {

    @Override
    public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException) throws IOException, ServletException {
        authException.printStackTrace();
       //InsufficientAuthenticationException 权限不足或没登录
        //BadCredentialsException 用户名或密码错误
        ResponseResult result = null;
        if(authException instanceof BadCredentialsException){
            result = ResponseResult.errorResult(AppHttpCodeEnum.LOGIN_ERROR.getCode(),authException.getMessage());
        }else if(authException instanceof InsufficientAuthenticationException){
            result = ResponseResult.errorResult(AppHttpCodeEnum.NEED_LOGIN);
        }else{
            result = ResponseResult.errorResult(AppHttpCodeEnum.SYSTEM_ERROR.getCode(),"认证或授权失败");
        }
        //响应给前端
        WebUtils.renderString(response, JSON.toJSONString(result));
    }
}

~~~~

com/xiaored/handler/security/AccessDeniedHandlerImpl.java

~~~~java
@Component
public class AccessDeniedHandlerImpl implements AccessDeniedHandler {
    @Override
    public void handle(HttpServletRequest request, HttpServletResponse response, AccessDeniedException accessDeniedException) throws IOException, ServletException {
        accessDeniedException.printStackTrace();
        ResponseResult result = ResponseResult.errorResult(AppHttpCodeEnum.NO_OPERATOR_AUTH);
        //响应给前端
        WebUtils.renderString(response, JSON.toJSONString(result));
    }
}

~~~~

**前台模块**

配置Security异常处理器

* 把上面实现的两个处理器注入
* 配置异常处理器

~~~~java
@Configuration
public class SecurityConfig extends WebSecurityConfigurerAdapter {

    @Override
    @Bean
    public AuthenticationManager authenticationManagerBean() throws Exception {
        return super.authenticationManagerBean();
    }

    @Autowired
    private JwtAuthenticationTokenFilter jwtAuthenticationTokenFilter;
    @Autowired
    AuthenticationEntryPoint authenticationEntryPoint;
    @Autowired
    AccessDeniedHandler accessDeniedHandler;


    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
                //关闭csrf
                .csrf().disable()
                //不通过Session获取SecurityContext
                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)
                .and()
                .authorizeRequests()
                // 对于登录接口 允许匿名访问
                .antMatchers("/login").anonymous()
                //jwt过滤器测试用，如果测试没有问题吧这里删除了
                .antMatchers("/link/getAllLink").authenticated()
                // 除上面外的所有请求全部不需要认证即可访问
                .anyRequest().permitAll();

        //配置异常处理器
        http.exceptionHandling()
                .authenticationEntryPoint(authenticationEntryPoint)
                .accessDeniedHandler(accessDeniedHandler);

        http.logout().disable();
        //把jwtAuthenticationTokenFilter添加到SpringSecurity的过滤器链中
        http.addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class);
        //允许跨域
        http.cors();
    }

    @Bean
    public PasswordEncoder passwordEncoder(){
        return new BCryptPasswordEncoder();
    }
}
~~~~

### 统一异常处理

实际在开发过程中可能需要做很多的判断校验，如果出现了非法情况，需要响应对应的提示的。（前端校验会被人绕过，因此后端还是要有校验）

但是如果每次都自己手动去处理就会非常麻烦。

可以选择直接抛出异常的方式，然后对异常进行统一处理。把异常中的信息封装成ResponseResult响应给前端。

​	
**公共模块**

com/xiaored/exception/SystemException.java

~~~~java
public class SystemException extends RuntimeException{

    private int code;

    private String msg;

    public int getCode() {
        return code;
    }

    public String getMsg() {
        return msg;
    }

    public SystemException(AppHttpCodeEnum httpCodeEnum) {
        super(httpCodeEnum.getMsg());
        this.code = httpCodeEnum.getCode();
        this.msg = httpCodeEnum.getMsg();
    } 
}
~~~~

com/xiaored/handler/exception/GlobalExceptionHandler.java

~~~~java
@RestControllerAdvice
@Slf4j
public class GlobalExceptionHandler {

    @ExceptionHandler(SystemException.class)
    public ResponseResult systemExceptionHandler(SystemException e){
        //打印异常信息
        log.error("出现了异常！ {}",e);
        //从异常对象中获取提示信息封装返回
        return ResponseResult.errorResult(e.getCode(),e.getMsg());
    }


    @ExceptionHandler(Exception.class)
    public ResponseResult exceptionHandler(Exception e){
        //打印异常信息
        log.error("出现了异常！ {}",e);
        //从异常对象中获取提示信息封装返回
        return ResponseResult.errorResult(AppHttpCodeEnum.SYSTEM_ERROR.getCode(),e.getMessage());
    }
}
~~~~

**前台模块**

controller里加一层判断

```java
@PostMapping("/login")
    public ResponseResult login(@RequestBody User user){
        if(!StringUtils.hasText(user.getUserName())){
            // 提示 必须要传用户名
            throw new SystemException(AppHttpCodeEnum.REQUIRE_USERNAME);
        }
        return blogLoginService.login(user);
    }
```

### 退出登录接口

#### 接口设计

| 请求方式 | 请求地址 | 请求头          |
| -------- | -------- | --------------- |
| POST     | /logout  | 需要token请求头 |

响应格式:

~~~~json
{
    "code": 200,
    "msg": "操作成功"
}
~~~~

#### 代码实现

要实现的操作：删除redis中的用户信息

BlogLoginController

~~~~java
    @PostMapping("/logout")
    public ResponseResult logout(){
        return blogLoginService.logout();
    }
~~~~

BlogLoginService

~~~~java
ResponseResult logout();
~~~~

BlogLoginServiceImpl

~~~~java
    @Override
    public ResponseResult logout() {
        //获取token 解析获取userid
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        LoginUser loginUser = (LoginUser) authentication.getPrincipal();
        //获取userid
        Long userId = loginUser.getUser().getId();
        //删除redis中的用户信息
        redisCache.deleteObject("bloglogin:"+userId);
        return ResponseResult.okResult();
    }
~~~~

SecurityConfig

* 注销接口需要认证才能访问
* 关闭默认的注销功能

~~~~java
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
                //关闭csrf
                .csrf().disable()
                //不通过Session获取SecurityContext
                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)
                .and()
                .authorizeRequests()
                // 对于登录接口 允许匿名访问
                .antMatchers("/login").anonymous()
            	//注销接口需要认证才能访问
                .antMatchers("/logout").authenticated()
                //jwt过滤器测试用，如果测试没有问题吧这里删除了
                .antMatchers("/link/getAllLink").authenticated()
                // 除上面外的所有请求全部不需要认证即可访问
                .anyRequest().permitAll();

        //配置异常处理器
        http.exceptionHandling()
                .authenticationEntryPoint(authenticationEntryPoint)
                .accessDeniedHandler(accessDeniedHandler);
		//关闭默认的注销功能
        http.logout().disable();
        //把jwtAuthenticationTokenFilter添加到SpringSecurity的过滤器链中
        http.addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class);
        //允许跨域
        http.cors();
    }
~~~~

### 查询评论列表接口

#### 需求

文章详情页面要展示这篇文章下的评论列表。

并且可以有父子评论（难点）

效果如下:

![image-20220208214106296](img/image-20220208214106296.png)

#### 评论表分析

建表SQL及初始化数据见：前后端分离博客系统\资源\SQL\xhr_comment.sql

通过需求去分析需要有哪些字段。

id，contentcreate_by，create_time，update_by，update_time，del_flag肯定要有

* type：评论类型（0代表文章评论，1代表友链评论）
* article_id：针对哪篇'文章id'评论
* root_id：根评论id（如果本身就是根评论，则为-1），这样可以得知根评论是谁以及本身是不是根评论
* to_comment_user_id：所回复的目标评论的userid
* to_comment_id：回复目标评论id（如果是根评论，则是-1）

**顺便自动生成下对应的代码**

#### 接口设计

| 请求方式 | 请求地址             | 请求头            |
| -------- | -------------------- | ----------------- |
| GET      | /comment/commentList | 不需要token请求头 |

Query格式请求参数：

articleId:文章id

pageNum: 页码

pageSize: 每页条数

响应格式:

~~~~json
{
    "code": 200,
    "data": {
        "rows": [
            {
                "articleId": "1",
                "children": [
                    {
                        "articleId": "1",
                        "content": "你说啥？",
                        "createBy": "1",
                        "createTime": "2022-01-30 10:06:21",
                        "id": "20",
                        "rootId": "1",
                        "toCommentId": "1",
                        "toCommentUserId": "1",
                        "toCommentUserName": "sg333",
                        "username": "sg333"
                    }
                ],
                "content": "asS",
                "createBy": "1",
                "createTime": "2022-01-29 07:59:22",
                "id": "1",
                "rootId": "-1",
                "toCommentId": "-1",
                "toCommentUserId": "-1",
                "username": "sg333"
            }
        ],
        "total": "15"
    },
    "msg": "操作成功"
}
~~~~

#### 代码实现

用easycode生成对应的实体类，mapper类，service类，serviceImpl类

##### 先不考虑子评论

**前台模块**

CommentController

~~~~java
@RestController
@RequestMapping("/comment")
public class CommentController {

    @Autowired
    private CommentService commentService;

    @GetMapping("/commentList")
    public ResponseResult commentList(Long articleId,Integer pageNum,Integer pageSize){
        return commentService.commentList(articleId,pageNum,pageSize);
    }
}
~~~~

**公共模块**

CommentService

~~~~java
public interface CommentService extends IService<Comment> {

    ResponseResult commentList(Long articleId, Integer pageNum, Integer pageSize);
}
~~~~

CommentServiceImpl

由于Comment实体类没有toCommentUserName和username，如果直接bean拷贝给CommentVo，那这两个属性会为null，因此定义toCommentVoList(List<Comment> list)单独对这两个属性添加值

**toCommentVoList(List<Comment> list)里要对获取到的user判断是否为空！！！！md找了好久才发现**

~~~~java
@Service("commentService")
public class CommentServiceImpl extends ServiceImpl<CommentMapper, Comment> implements CommentService {

    @Autowired
    private UserService userService;

    @Override
    public ResponseResult commentList(Long articleId, Integer pageNum, Integer pageSize) {
        //查询对应文章的根评论
        LambdaQueryWrapper<Comment> queryWrapper = new LambdaQueryWrapper<>();
        //对articleId进行判断
        queryWrapper.eq(Comment::getArticleId,articleId);
        //根评论 rootId为-1
        queryWrapper.eq(Comment::getRootId,-1);

        //分页查询
        Page<Comment> page = new Page(pageNum,pageSize);
        page(page,queryWrapper);

        List<CommentVo> commentVoList = toCommentVoList(page.getRecords());

        return ResponseResult.okResult(new PageVo(commentVoList,page.getTotal()));
    }

    private List<CommentVo> toCommentVoList(List<Comment> list){
        List<CommentVo> commentVos = BeanCopyUtils.copyBeanList(list, CommentVo.class);
        //遍历vo集合
        for (CommentVo commentVo : commentVos) {
            User user=userService.getById(commentVo.getCreateBy());
            if(user!=null){
                //通过creatyBy查询用户的昵称并赋值
                String nickName = user.getNickName();
                commentVo.setUsername(nickName);
                //通过toCommentUserId查询用户的昵称并赋值
                //如果toCommentUserId不为-1才进行查询
                if(commentVo.getToCommentUserId()!=-1){
                    String toCommentUserName =user.getNickName();
                    commentVo.setToCommentUserName(toCommentUserName);
                }
            }
        }
        return commentVos;
    }
}
~~~~

CommentVo

~~~~java
@Data
@NoArgsConstructor
@AllArgsConstructor
public class CommentVo {
    private Long id;
    //文章id
    private Long articleId;
    //根评论id
    private Long rootId;
    //评论内容
    private String content;
    //所回复的目标评论的userid
    private Long toCommentUserId;
    private String toCommentUserName;
    //回复目标评论id
    private Long toCommentId;

    private Long createBy;

    private Date createTime;

    private String username;
}
~~~~

##### 查询子评论

CommentVo在之前的基础上增加`private List<CommentVo> children`;

CommentServiceImpl

添加`getChildren(Long id)`

~~~~java
@Service("commentService")
public class CommentServiceImpl extends ServiceImpl<CommentMapper, Comment> implements CommentService {

    @Autowired
    private UserService userService;

    @Override
    public ResponseResult commentList(Long articleId, Integer pageNum, Integer pageSize) {
        //查询对应文章的根评论
        LambdaQueryWrapper<Comment> queryWrapper = new LambdaQueryWrapper<>();
        //对articleId进行判断
        queryWrapper.eq(Comment::getArticleId,articleId);
        //根评论 rootId为-1
        queryWrapper.eq(Comment::getRootId,-1);

        //分页查询
        Page<Comment> page = new Page(pageNum,pageSize);
        page(page,queryWrapper);

        List<CommentVo> commentVoList = toCommentVoList(page.getRecords());

        //查询所有根评论对应的子评论集合，并且赋值给对应的属性
        for (CommentVo commentVo : commentVoList) {
            //查询对应的子评论
            List<CommentVo> children = getChildren(commentVo.getId());
            //赋值
            commentVo.setChildren(children);
        }

        return ResponseResult.okResult(new PageVo(commentVoList,page.getTotal()));
    }

    /**
     * 根据根评论的id查询所对应的子评论的集合
     * @param id 根评论的id
     * @return
     */
    private List<CommentVo> getChildren(Long id) {

        LambdaQueryWrapper<Comment> queryWrapper = new LambdaQueryWrapper<>();
        queryWrapper.eq(Comment::getRootId,id);
        queryWrapper.orderByAsc(Comment::getCreateTime);
        List<Comment> comments = list(queryWrapper);

        List<CommentVo> commentVos = toCommentVoList(comments);
        return commentVos;
    }

    private List<CommentVo> toCommentVoList(List<Comment> list){
        List<CommentVo> commentVos = BeanCopyUtils.copyBeanList(list, CommentVo.class);
        //遍历vo集合
        for (CommentVo commentVo : commentVos) {
            User user=userService.getById(commentVo.getCreateBy());
            if(user!=null){
                //通过creatyBy查询用户的昵称并赋值
                String nickName = user.getNickName();
                commentVo.setUsername(nickName);
                //通过toCommentUserId查询用户的昵称并赋值
                //如果toCommentUserId不为-1才进行查询
                if(commentVo.getToCommentUserId()!=-1){
                    String toCommentUserName =user.getNickName();
                    commentVo.setToCommentUserName(toCommentUserName);
                }
            }
        }
        return commentVos;
    }
}
~~~~

### 发表评论接口

#### 需求

用户登录后可以对文章发表评论，也可以对评论进行回复。

用户登录后也可以在友链页面进行评论。

#### 接口设计

| 请求方式 | 请求地址 | 请求头      |
| -------- | -------- | ----------- |
| POST     | /comment | 需要token头 |

**请求体**

回复了文章：

~~~~json
{"articleId":1,"type":0,"rootId":-1,"toCommentId":-1,"toCommentUserId":-1,"content":"评论了文章"}
~~~~

回复了某条评论：

~~~~json
{"articleId":1,"type":0,"rootId":"3","toCommentId":"3","toCommentUserId":"1","content":"回复了某条评论"}
~~~~

如果是友链评论，type应该为1

**响应格式**

~~~~java
{
	"code":200,
	"msg":"操作成功"
}
~~~~

#### 代码实现

**前台模块**

CommentController

~~~~java
    @PostMapping
    public ResponseResult addComment(@RequestBody Comment comment){
        return commentService.addComment(comment);
    }
~~~~

**公共模块**

CommentService

~~~~java
ResponseResult addComment(Comment comment);
~~~~

CommentServiceImpl

~~~~java
    @Override
    public ResponseResult addComment(Comment comment) {
        //评论内容不能为空
        if(!StringUtils.hasText(comment.getContent())){
            throw new SystemException(AppHttpCodeEnum.CONTENT_NOT_NULL);
        }
        save(comment);
        return ResponseResult.okResult();
    }
~~~~

SecurityUtils

~~~~java
/**
 * @Author 三更
 */
public class SecurityUtils
{

    /**
     * 获取用户
     **/
    public static LoginUser getLoginUser()
    {
        return (LoginUser) getAuthentication().getPrincipal();
    }

    /**
     * 获取Authentication
     */
    public static Authentication getAuthentication() {
        return SecurityContextHolder.getContext().getAuthentication();
    }

    public static Boolean isAdmin(){
        Long id = getLoginUser().getUser().getId();
        return id != null && 1L == id;
    }

    public static Long getUserId() {
        return getLoginUser().getUser().getId();
    }
}
~~~~

配置MybatisPlus字段自动填充

com/xiaored/handler/MybatisPlus/MyMetaObjectHandler.java

~~~~java
@Component
public class MyMetaObjectHandler implements MetaObjectHandler {
    @Override
    public void insertFill(MetaObject metaObject) {
        Long userId = null;
        try {
            userId = SecurityUtils.getUserId();
        } catch (Exception e) {
            e.printStackTrace();
            userId = -1L;//表示是自己创建
        }
        this.setFieldValByName("createTime", new Date(), metaObject);
        this.setFieldValByName("createBy",userId , metaObject);
        this.setFieldValByName("updateTime", new Date(), metaObject);
        this.setFieldValByName("updateBy", userId, metaObject);
    }

    @Override
    public void updateFill(MetaObject metaObject) {
        this.setFieldValByName("updateTime", new Date(), metaObject);
        this.setFieldValByName(" ", SecurityUtils.getUserId(), metaObject);
    }
}
~~~~

Comment实体类中用注解标识哪些字段在什么情况下需要自动填充

~~~~java
    /**
     * 创建人的用户id
     */
    @TableField(fill = FieldFill.INSERT)
    private Long createBy;
    /**
     * 创建时间
     */
    @TableField(fill = FieldFill.INSERT)
    private Date createTime;
    /**
     * 更新人
     */
    @TableField(fill = FieldFill.INSERT_UPDATE)
    private Long updateBy;
    /**
     * 更新时间
     */
    @TableField(fill = FieldFill.INSERT_UPDATE)
    private Date updateTime;
~~~~

### 友联评论列表

#### 需求

友链页面也需要查询对应的评论列表。

#### 接口设计

| 请求方式 | 请求地址                 | 请求头            |
| -------- | ------------------------ | ----------------- |
| GET      | /comment/linkCommentList | 不需要token请求头 |

Query格式请求参数：

pageNum: 页码

pageSize: 每页条数

响应格式:

~~~~json
{
    "code": 200,
    "data": {
        "rows": [
            {
                "articleId": "1",
                "children": [
                    {
                        "articleId": "1",
                        "content": "回复友链评论3",
                        "createBy": "1",
                        "createTime": "2022-01-30 10:08:50",
                        "id": "23",
                        "rootId": "22",
                        "toCommentId": "22",
                        "toCommentUserId": "1",
                        "toCommentUserName": "sg333",
                        "username": "sg333"
                    }
                ],
                "content": "友链评论2",
                "createBy": "1",
                "createTime": "2022-01-30 10:08:28",
                "id": "22",
                "rootId": "-1",
                "toCommentId": "-1",
                "toCommentUserId": "-1",
                "username": "sg333"
            }
        ],
        "total": "1"
    },
    "msg": "操作成功"
}
~~~~


#### 代码实现

**前台模块**

CommentController

修改了之前的文章评论列表接口，并且增加了新的友联评论接口

~~~~java
    @GetMapping("/commentList")
    public ResponseResult commentList(Long articleId,Integer pageNum,Integer pageSize){
        return commentService.commentList(SystemConstants.ARTICLE_COMMENT,articleId,pageNum,pageSize);
    }   
    @GetMapping("/linkCommentList")
    public ResponseResult linkCommentList(Integer pageNum,Integer pageSize){
        return commentService.commentList(SystemConstants.LINK_COMMENT,null,pageNum,pageSize);
    }
~~~~

**公共模块**

SystemConstants增加了两个常量

~~~~java
    /**
     * 评论类型为：文章评论
     */
    public static final String ARTICLE_COMMENT = "0";
    /**
     * 评论类型为：友联评论
     */
    public static final String LINK_COMMENT = "1";
~~~~

CommentService修改了commentList方法，增加了一个参数commentType

~~~~java
ResponseResult commentList(String commentType, Long articleId, Integer pageNum, Integer pageSize);
~~~~

CommentServiceImpl修改commentList方法的代码，必须commentType为0的时候才增加articleId的判断，并且增加了一个评论类型的添加。

~~~~java
    @Override
    public ResponseResult commentList(String commentType, Long articleId, Integer pageNum, Integer pageSize) {
        //查询对应文章的根评论
        LambdaQueryWrapper<Comment> queryWrapper = new LambdaQueryWrapper<>();
        //对articleId进行判断
        queryWrapper.eq(SystemConstants.ARTICLE_COMMENT.equals(commentType),Comment::getArticleId,articleId);
        //根评论 rootId为-1
        queryWrapper.eq(Comment::getRootId,-1);

        //评论类型
        queryWrapper.eq(Comment::getType,commentType);

        //分页查询
        Page<Comment> page = new Page(pageNum,pageSize);
        page(page,queryWrapper);

        List<CommentVo> commentVoList = toCommentVoList(page.getRecords());

        //查询所有根评论对应的子评论集合，并且赋值给对应的属性
        for (CommentVo commentVo : commentVoList) {
            //查询对应的子评论
            List<CommentVo> children = getChildren(commentVo.getId());
            //赋值
            commentVo.setChildren(children);
        }

        return ResponseResult.okResult(new PageVo(commentVoList,page.getTotal()));
    }
~~~~

### 个人信息查询接口

#### 需求

进入个人中心的时候需要能够查看当前用户信息

#### 接口设计

| 请求方式 | 请求地址       | 请求头          |
| -------- | -------------- | --------------- |
| GET      | /user/userInfo | 需要token请求头 |

不需要参数

响应格式:

~~~~json
{
	"code":200,
	"data":{
		"avatar":"https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fi0.hdslb.com%2Fbfs%2Farticle%2F3bf9c263bc0f2ac5c3a7feb9e218d07475573ec8.gi",
		"email":"23412332@qq.com",
		"id":"1",
		"nickName":"sg333",
		"sex":"1"
	},
	"msg":"操作成功"
}
~~~~

#### 代码实现

**前台代码**

UserController

~~~~java
@RestController
@RequestMapping("/user")
public class UserController {

    @Autowired
    private UserService userService;

    @GetMapping("/userInfo")
    public ResponseResult userInfo(){
        return userService.userInfo();
    }
}

~~~~

**公共模块**

UserService增加方法定义

~~~~java
public interface UserService extends IService<User> {

    ResponseResult userInfo();

}

~~~~

UserServiceImpl实现userInfo方法

~~~~java
    @Override
    public ResponseResult userInfo() {
        //获取当前用户id
        Long userId = SecurityUtils.getUserId();
        //根据用户id查询用户信息
        User user = getById(userId);
        //封装成UserInfoVo
        UserInfoVo vo = BeanCopyUtils.copyBean(user,UserInfoVo.class);
        return ResponseResult.okResult(vo);
    }
~~~~

SecurityConfig配置该接口必须认证后才能访问

~~~~java
   @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
                //关闭csrf
                .csrf().disable()
                //不通过Session获取SecurityContext
                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)
                .and()
                .authorizeRequests()
                // 对于登录接口 允许匿名访问
                .antMatchers("/login").anonymous()
                //注销接口需要认证才能访问
                .antMatchers("/logout").authenticated()
            	//个人信息接口必须登录后才能访问
                .antMatchers("/user/userInfo").authenticated()
                // 除上面外的所有请求全部不需要认证即可访问
                .anyRequest().permitAll();

        //配置异常处理器
        http.exceptionHandling()
                .authenticationEntryPoint(authenticationEntryPoint)
                .accessDeniedHandler(accessDeniedHandler);
        //关闭默认的注销功能
        http.logout().disable();
        //把jwtAuthenticationTokenFilter添加到SpringSecurity的过滤器链中
        http.addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class);
        //允许跨域
        http.cors();
    }
~~~~

### 头像上传接口

#### 需求

在个人中心点击编辑的时候可以上传头像图片。上传完头像后，可以用于更新个人信息接口。

#### OSS

##### 为什么要使用OSS

如果把图片视频等文件上传到自己的应用的Web服务器，在读取图片的时候会占用比较多的资源。影响应用服务器的性能。

所以一般使用OSS(Object Storage Service对象存储服务)存储图片或视频。

##### 七牛云注册及基本使用

![image-20220227224537701](img/image-20220227224537701.png)

![image-20220227224443813](img/image-20220227224443813.png)

秘钥

![image-20220228230512598](img/image-20220228230512598.png)

![image-20220228230933808](img/image-20220228230933808.png)

##### 七牛云测试代码编写

①添加依赖

~~~~xml
        <dependency>
            <groupId>com.qiniu</groupId>
            <artifactId>qiniu-java-sdk</artifactId>
            <version>[7.7.0, 7.7.99]</version>
        </dependency>
~~~~

②复制修改案例代码

application.yml

~~~~yml
oss:
  accessKey: xxxx
  secretKey: xxxx
  bucket: xhr-blog
~~~~

前台模块的test目录下创建com/xiaored/OSSTest.java

~~~~java
@SpringBootTest
@ConfigurationProperties(prefix = "oss")
public class OSSTest {

    private String accessKey;
    private String secretKey;
    private String bucket;

    public void setAccessKey(String accessKey) {
        this.accessKey = accessKey;
    }

    public void setSecretKey(String secretKey) {
        this.secretKey = secretKey;
    }

    public void setBucket(String bucket) {
        this.bucket = bucket;
    }

    @Test
    public void testOss(){
        //构造一个带指定 Region 对象的配置类
        Configuration cfg = new Configuration(Region.autoRegion());
        //...其他参数参考类注释

        UploadManager uploadManager = new UploadManager(cfg);
        //...生成上传凭证，然后准备上传
//        String accessKey = "your access key";
//        String secretKey = "your secret key";
//        String bucket = "xhr-blog";

        //默认不指定key的情况下，以文件内容的hash值作为文件名
        String key = "2022/xhr.png";

        try {
//            byte[] uploadBytes = "hello qiniu cloud".getBytes("utf-8");
//            ByteArrayInputStream byteInputStream=new ByteArrayInputStream(uploadBytes);


            InputStream inputStream = new FileInputStream("C:\\Users\\root\\Desktop\\Snipaste_2022-02-28_22-48-37.png");
            Auth auth = Auth.create(accessKey, secretKey);
            String upToken = auth.uploadToken(bucket);

            try {
                Response response = uploadManager.put(inputStream,key,upToken,null, null);
                //解析上传成功的结果
                DefaultPutRet putRet = new Gson().fromJson(response.bodyString(), DefaultPutRet.class);
                System.out.println(putRet.key);
                System.out.println(putRet.hash);
            } catch (QiniuException ex) {
                Response r = ex.response;
                System.err.println(r.toString());
                try {
                    System.err.println(r.bodyString());
                } catch (QiniuException ex2) {
                    //ignore
                }
            }
        } catch (Exception ex) {
            //ignore
        }

    }
}
~~~~

#### 接口设计

| 请求方式 | 请求地址 | 请求头    |
| -------- | -------- | --------- |
| POST     | /upload  | 需要token |

参数：

​	img,值为要上传的文件

请求头：

​	Content-Type ：multipart/form-data;



响应格式:

~~~~json
{
    "code": 200,
    "data": "文件访问链接",
    "msg": "操作成功"
}
~~~~

#### 代码实现

**前台模块**

创建UploadController

~~~~java
@RestController
public class UploadController {
    @Autowired
    private UploadService uploadService;

    @PostMapping("/upload")
    public ResponseResult uploadImg(MultipartFile img){
        return uploadService.uploadImg(img);
    }
}

~~~~

**公共模块**

创建UploadService

~~~~java
public interface UploadService {
    ResponseResult uploadImg(MultipartFile img);
}

~~~~

创建OssUploadService实现UploadService

~~~~java
@Service
@Data
@ConfigurationProperties(prefix = "oss")
public class OssUploadService implements UploadService {
    @Override
    public ResponseResult uploadImg(MultipartFile img) {
        //判断文件类型
        //获取原始文件名
        String originalFilename = img.getOriginalFilename();
        //对原始文件名进行判断
        if(!originalFilename.endsWith(".png")){
            throw new SystemException(AppHttpCodeEnum.FILE_TYPE_ERROR);
        }

        //如果判断通过上传文件到OSS
        String filePath = PathUtils.generateFilePath(originalFilename);
        String url = uploadOss(img,filePath);//  2099/2/3/wqeqeqe.png
        return ResponseResult.okResult(url);
    }

    private String accessKey;
    private String secretKey;
    private String bucket;


    private String uploadOss(MultipartFile imgFile, String filePath){
        //构造一个带指定 Region 对象的配置类
        Configuration cfg = new Configuration(Region.autoRegion());
        //...其他参数参考类注释
        UploadManager uploadManager = new UploadManager(cfg);
        //默认不指定key的情况下，以文件内容的hash值作为文件名
        String key = filePath;
        try {
            InputStream inputStream = imgFile.getInputStream();
            Auth auth = Auth.create(accessKey, secretKey);
            String upToken = auth.uploadToken(bucket);
            try {
                Response response = uploadManager.put(inputStream,key,upToken,null, null);
                //解析上传成功的结果
                DefaultPutRet putRet = new Gson().fromJson(response.bodyString(), DefaultPutRet.class);
                System.out.println(putRet.key);
                System.out.println(putRet.hash);
                return "http://r7yxkqloa.bkt.clouddn.com/"+key;
            } catch (QiniuException ex) {
                Response r = ex.response;
                System.err.println(r.toString());
                try {
                    System.err.println(r.bodyString());
                } catch (QiniuException ex2) {
                    //ignore
                }
            }
        } catch (Exception ex) {
            //ignore
        }
        return "www";
    }
}

~~~~

PathUtils

~~~~java
/**
 * @Author
 */
public class PathUtils {

    public static String generateFilePath(String fileName){
        //根据日期生成路径   2022/1/15/
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy/MM/dd/");
        String datePath = sdf.format(new Date());
        //uuid作为文件名
        String uuid = UUID.randomUUID().toString().replaceAll("-", "");
        //后缀和文件后缀一致
        int index = fileName.lastIndexOf(".");
        // test.jpg -> .jpg
        String fileType = fileName.substring(index);
        return new StringBuilder().append(datePath).append(uuid).append(fileType).toString();
    }
}

~~~~

### 更新个人信息接口

#### 需求

在编辑完个人资料后点击保存会对个人资料进行更新。

#### 接口设计

| 请求方式 | 请求地址       | 请求头          |
| -------- | -------------- | --------------- |
| PUT      | /user/userInfo | 需要token请求头 |

参数

请求体中json格式数据：

~~~~json
{
    "avatar":"https://sg-blog-oss.oss-cn-beijing.aliyuncs.com/2022/01/31/948597e164614902ab1662ba8452e106.png",
    "email":"23412332@qq.com",
    "id":"1",
    "nickName":"sg333",
    "sex":"1"
}
~~~~

响应格式:

~~~~json
{
	"code":200,
	"msg":"操作成功"
}
~~~~

#### 代码实现

**前台模块**

UserController添加：

~~~~java
    @PutMapping("/userInfo")
    public ResponseResult updateUserInfo(@RequestBody User user){
        return userService.updateUserInfo(user);
    }
~~~~

**公共模块**

UserService

~~~~java
ResponseResult updateUserInfo(User user);
~~~~

UserServiceImpl

~~~~java
    @Override
    public ResponseResult updateUserInfo(User user) {
        updateById(user);
        return ResponseResult.okResult();
    }
~~~~

### 用户注册

#### 需求

要求用户能够在注册界面完成用户的注册。要求用户名，昵称，邮箱不能和数据库中原有的数据重复。如果某项重复了注册失败并且要有对应的提示。并且要求用户名，密码，昵称，邮箱都不能为空。

注意:密码必须密文存储到数据库中。

#### 接口设计

| 请求方式 | 请求地址       | 请求头            |
| -------- | -------------- | ----------------- |
| POST     | /user/register | 不需要token请求头 |

参数

请求体中json格式数据：

~~~~json
{
  "email": "string",
  "nickName": "string",
  "password": "string",
  "userName": "string"
}
~~~~

响应格式:

~~~~json
{
	"code":200,
	"msg":"操作成功"
}
~~~~

#### 代码实现

UserController

~~~~java
    @PostMapping("/register")
    public ResponseResult register(@RequestBody User user){
        return userService.register(user);
    }
~~~~

UserService

~~~~java
ResponseResult register(User user);
~~~~

UserServiceImpl

~~~~java
    @Autowired
    private PasswordEncoder passwordEncoder;
    @Override
    public ResponseResult register(User user) {
        //对数据进行非空判断
        if(!StringUtils.hasText(user.getUserName())){
            throw new SystemException(AppHttpCodeEnum.USERNAME_NOT_NULL);
        }
        if(!StringUtils.hasText(user.getPassword())){
            throw new SystemException(AppHttpCodeEnum.PASSWORD_NOT_NULL);
        }
        if(!StringUtils.hasText(user.getEmail())){
            throw new SystemException(AppHttpCodeEnum.EMAIL_NOT_NULL);
        }
        if(!StringUtils.hasText(user.getNickName())){
            throw new SystemException(AppHttpCodeEnum.NICKNAME_NOT_NULL);
        }
        //对数据进行是否存在的判断
        if(userNameExist(user.getUserName())){
            throw new SystemException(AppHttpCodeEnum.USERNAME_EXIST);
        }
        if(nickNameExist(user.getNickName())){
            throw new SystemException(AppHttpCodeEnum.NICKNAME_EXIST);
        }
        //...
        //对密码进行加密
        String encodePassword = passwordEncoder.encode(user.getPassword());
        user.setPassword(encodePassword);
        //存入数据库
        save(user);
        return ResponseResult.okResult();
    }

    private boolean nickNameExist(String nickName) {
        LambdaQueryWrapper<User> queryWrapper = new LambdaQueryWrapper<>();
        queryWrapper.eq(User::getNickName,nickName);
        return count(queryWrapper)>0;
    }

    private boolean userNameExist(String userName) {
        LambdaQueryWrapper<User> queryWrapper = new LambdaQueryWrapper<>();
        queryWrapper.eq(User::getUserName,userName);
        return count(queryWrapper)>0;
    }
~~~~

~~~~java
public enum AppHttpCodeEnum {
    // 成功
    SUCCESS(200,"操作成功"),
    // 登录
    NEED_LOGIN(401,"需要登录后操作"),
    NO_OPERATOR_AUTH(403,"无权限操作"),
    SYSTEM_ERROR(500,"出现错误"),
    USERNAME_EXIST(501,"用户名已存在"),
     PHONENUMBER_EXIST(502,"手机号已存在"), EMAIL_EXIST(503, "邮箱已存在"),
    REQUIRE_USERNAME(504, "必需填写用户名"),
    CONTENT_NOT_NULL(506, "评论内容不能为空"),
    FILE_TYPE_ERROR(507, "文件类型错误，请上传png文件"),
    USERNAME_NOT_NULL(508, "用户名不能为空"),
    NICKNAME_NOT_NULL(509, "昵称不能为空"),
    PASSWORD_NOT_NULL(510, "密码不能为空"),
    EMAIL_NOT_NULL(511, "邮箱不能为空"),
    NICKNAME_EXIST(512, "昵称已存在"),
    LOGIN_ERROR(505,"用户名或密码错误");
    int code;
    String msg;

    AppHttpCodeEnum(int code, String errorMessage){
        this.code = code;
        this.msg = errorMessage;
    }

    public int getCode() {
        return code;
    }

    public String getMsg() {
        return msg;
    }
}
~~~~

### AOP实现日志记录(这方面知识真的欠缺啊)

#### 需求

需要通过日志记录接口调用信息。便于后期调试排查。并且可能有很多接口都需要进行日志的记录。

接口被调用时日志打印格式如下：

![image-20220313133714102](img/image-20220313133714102.png)

#### 思路分析

相当于是对原有的功能进行增强。并且是批量的增强，这个时候就非常适合用AOP来进行实现。

#### 代码实现

日志打印格式

~~~~java
        log.info("=======Start=======");
        // 打印请求 URL
        log.info("URL            : {}",);
        // 打印描述信息
        log.info("BusinessName   : {}", );
        // 打印 Http method
        log.info("HTTP Method    : {}", );
        // 打印调用 controller 的全路径以及执行方法
        log.info("Class Method   : {}.{}", );
        // 打印请求的 IP
        log.info("IP             : {}",);
        // 打印请求入参
        log.info("Request Args   : {}",);
        // 打印出参
        log.info("Response       : {}", );
        // 结束后换行
        log.info("=======End=======" + System.lineSeparator());
~~~~

**公共模块**

创建com/xiaored/annotation/SystemLog.java

自定义注解，希望加上注解的方法都会进行AOP增强日志打印

```java
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.METHOD})
public @interface SystemLog {
    String businessName();
}
```

创建com/xiaored/aspect/LogAspect.java

```java
@Component
@Aspect
@Slf4j
public class LogAspect {
    //确定切点
    @Pointcut("@annotation(com.xiaored.annotation.SystemLog)")
    public void pt(){

    }

    //定义通知方法
    @Around("pt()")
    public Object printLog(ProceedingJoinPoint joinPoint) throws Throwable {
        Object ret;
        try {
            handlerBefore(joinPoint);
            ret = joinPoint.proceed();
            handlerAfter(ret);
        } finally {
            // 结束后换行
            log.info("=======End=======" + System.lineSeparator());
        }

        return ret;
    }

    private void handlerAfter(Object ret) {
        // 打印出参
        log.info("Response       : {}",JSON.toJSONString(ret) );
    }

    private void handlerBefore(ProceedingJoinPoint joinPoint) {
        ServletRequestAttributes requestAttributes=(ServletRequestAttributes)RequestContextHolder.getRequestAttributes();
        HttpServletRequest request=requestAttributes.getRequest();

        //获取被增强方法上的注解对象
        SystemLog systemLog=getSystemLog(joinPoint);

        log.info("=======Start=======");
        // 打印请求 URL
        log.info("URL            : {}",request.getRequestURL());
        // 打印描述信息
        log.info("BusinessName   : {}", systemLog.businessName());
        // 打印 Http method
        log.info("HTTP Method    : {}", request.getMethod());
        // 打印调用 controller 的全路径以及执行方法
        log.info("Class Method   : {}.{}", joinPoint.getSignature().getDeclaringTypeName(),(MethodSignature) joinPoint.getSignature());
        // 打印请求的 IP
        log.info("IP             : {}",request.getRemoteHost());
        // 打印请求入参
        log.info("Request Args   : {}", JSON.toJSONString(joinPoint.getArgs()));
    }

    private SystemLog getSystemLog(ProceedingJoinPoint joinPoint) {
        MethodSignature methodSignature=(MethodSignature) joinPoint.getSignature();
        SystemLog systemLog=methodSignature.getMethod().getAnnotation(SystemLog.class);
        return systemLog;
    }
}
```

#### 测试

拿查询文章详情为例

```java
@GetMapping("/{id}")
    @SystemLog(businessName = "查询文章详细信息")
    public ResponseResult getArticleDetail(@PathVariable("id") Long id){
        return articleService.getArticleDetail(id);//通过文章id得到文章详情
    }
```

查询前打印日志：

![](img/AOP%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C1.png)

查询后打印日志：

![](img/AOP%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C2.png)

### 更新浏览次数

#### 需求

在用户浏览博文时要实现对应博客浏览量的增加。

#### 思路分析

只需要在每次用户浏览博客时更新对应的浏览数即可。

但是如果直接操作博客表的浏览量的话，在并发量大的情况下会出现什么问题呢？

如何去优化呢？

①在应用启动时把博客的浏览量存储到redis中

②更新浏览量时去更新redis中的数据

③每隔10分钟把Redis中的浏览量更新到数据库中

④读取文章浏览量时从redis读取

#### 铺垫知识

##### CommandLineRunner实现项目启动时预处理

如果希望在SpringBoot应用启动时进行一些初始化操作可以选择使用CommandLineRunner来进行处理。

只需要实现CommandLineRunner接口，并且把对应的bean注入容器。把相关初始化的代码重新到需要重新的方法中。

这样就会在应用启动的时候执行对应的代码。

~~~~java
@Component
public class TestRunner implements CommandLineRunner {
    @Override
    public void run(String... args) throws Exception {
        System.out.println("程序初始化");
    }
}

~~~~

##### 定时任务

定时任务的实现方式有很多，比如XXL-Job等。但是其实核心功能和概念都是类似的，很多情况下只是调用的API不同而已。

这里用SpringBoot提供的定时任务的API来实现一个简单的定时任务

实现步骤

① 使用`@EnableScheduling`注解开启定时任务功能

可以在配置类上加上@EnableScheduling

~~~~java
@SpringBootApplication
@MapperScan("com.xiaored.mapper")
@EnableScheduling
public class XiaoRedBlogApplication {

    public static void main(String[] args) {
        SpringApplication.run(XiaoRedBlogApplication.class,args);
    }
}
~~~~

② 确定定时任务执行代码，并配置任务执行时间

使用`@Scheduled`注解标识需要定时执行的代码。注解的cron属性相当于是任务的执行时间。目前可以使用 0/5 * * * * ? 进行测试，代表从0秒开始，每隔5秒执行一次。 

注意：对应的bean要注入容器，否则不会生效。

~~~~java
@Component
public class TestJob {

    @Scheduled(cron = "0/5 * * * * ?")
    public void testJob(){
        //要执行的代码
        System.out.println("定时任务执行了");
    }
}

~~~~

###### cron 表达式语法

cron表达式是用来设置定时任务执行时间的表达式。

用 ： [在线Cron表达式生成器](https://www.bejson.com/othertools/cron/) 来帮助理解和书写cron表达式。

**简单了解**

如上用到的 0/5 * * * * ? *，cron表达式由七部分组成，中间由空格分隔，这七部分从左往右依次是：

秒（0~ 59），分钟（0~ 59），小时（0~ 23），日期（1-月最后一天），月份（1-12），星期几（1-7,1表示星期日），年份（一般该项不设置，直接忽略掉，即可为空值）

通用特殊字符：, - * /  (可以在任意部分使用)

> *

星号表示任意值，例如：

表示 “ 每年每月每天每时每分每秒 ” 。

```
* * * * * ?
```

> ,   //可以用来定义列表

例如

表示 “ 每年每月每天每时每分的每个第1秒，第2秒，第3秒 ” 。

```
1,2,3 * * * * ?
```

> -

定义范围，例如：

表示 “ 每年每月每天每时每分的第1秒至第3秒 ”。

```
1-3 * * * * ?
```

> /

每隔多少，例如

表示 “ 每年每月每天每时每分，从第5秒开始，每10秒一次 ” 。即 “ / ” 的左侧是开始值，右侧是间隔。如果是从 “ 0 ” 开始的话，也可以简写成 “ /10 ” 

```
5/10 * * * * ?
```


日期部分还可允许特殊字符： ? L W

星期部分还可允许的特殊字符: ? L # 

> ?

只可用在日期和星期部分。表示没有具体的值，使用?要注意冲突。日期和星期两个部分如果其中一个部分设置了值，则另一个必须设置为 “ ? ”。

例如：

~~~~
0\* * * 2 * ?
 和
0\* * * ? * 2
~~~~

同时使用?和同时不使用?都是不对的

例如下面写法就是错的

~~~~
* * * 2 * 2
 和
* * * ? * ?

~~~~

> W

只能用在日期中，表示当月中最接近某天的工作日

```
0 0 0 31W * ?
```

表示最接近31号的工作日，如果31号是星期六，则表示30号，即星期五，如果31号是星期天，则表示29号，即星期五。如果31号是星期三，则表示31号本身，即星期三。

> L

表示最后（Last）,只能用在日期和星期中

在日期中表示每月最后一天，在一月份中表示31号，在六月份中表示30号

也可以表示每月倒是第N天。例如： L-2表示每个月的倒数第2天



 0 0 0 LW * ?
 LW可以连起来用，表示每月最后一个工作日，即每月最后一个星期五



在星期中表示7即星期六


~~~~
0 0 0 ? * L
表示每个星期六
0 0 0 ? * 6L
若前面有其他值的话，则表示最后一个星期几，即每月的最后一个星期五
~~~~

> # 

只能用在星期中，表示第几个星期几

~~~~
0 0 0 ? * 6#3
表示每个月的第三个星期五。
~~~~

#### 接口设计

| 请求方式 | 请求地址                      | 请求头            |
| -------- | ----------------------------- | ----------------- |
| PUT      | /article/updateViewCount/{id} | 不需要token请求头 |

参数

​	请求路径中携带文章id

响应格式:

~~~~json
{
	"code":200,
	"msg":"操作成功"
}
~~~~

#### 代码实现

##### ①在应用启动时把博客的浏览量存储到redis中

**前台模块**

创建com/xiaored/runner/ViewCountRunner.java

实现CommandLineRunner接口，在应用启动时初始化缓存。

~~~~java
@Component
public class ViewCountRunner implements CommandLineRunner {

    @Autowired
    private ArticleMapper articleMapper;

    @Autowired
    private RedisCache redisCache;

    @Override
    public void run(String... args) throws Exception {
        //查询博客信息  id  viewCount
        List<Article> articles = articleMapper.selectList(null);
        Map<String, Integer> viewCountMap = articles.stream()
                .collect(Collectors.toMap(article -> article.getId().toString(), article -> {
                    return article.getViewCount().intValue();//
                }));
        //存储到redis中
        redisCache.setCacheMap("article:viewCount",viewCountMap);
    }
}
~~~~

##### ②更新浏览量时去更新redsi中的数据

**公共模块**    

RedisCache增加方法   

~~~~java
    public void incrementCacheMapValue(String key,String hKey,long v){
        redisTemplate.boundHashOps(key).increment(hKey, v);
    }
~~~~

ArticleController中增加方法更新阅读数

~~~~java
    @PutMapping("/updateViewCount/{id}")
    public ResponseResult updateViewCount(@PathVariable("id") Long id){
        return articleService.updateViewCount(id);
    }
~~~~

ArticleService中增加方法

~~~~java
ResponseResult updateViewCount(Long id);
~~~~

ArticleServiceImpl中实现方法

~~~~java
    @Autowired
    RedisCache redisCache;
    @Override
    public ResponseResult updateViewCount(Long id) {
        //更新redis中对应 id的浏览量
        redisCache.incrementCacheMapValue("article:viewCount",id.toString(),1);
        return ResponseResult.okResult();
    }
~~~~

##### ③定时任务每隔10分钟把Redis中的浏览量更新到数据库中

Article中增加构造方法

~~~~java
    public Article(Long id, long viewCount) {
        this.id = id;
        this.viewCount = viewCount;
    }
~~~~

**前台模块**

创建com/xiaored/job/UpdateViewCountJob.java

~~~~java
@Component
public class UpdateViewCountJob {

    @Autowired
    private RedisCache redisCache;

    @Autowired
    private ArticleService articleService;

    @Scheduled(cron = "0/5 * * * * ?")
    public void updateViewCount(){
        //获取redis中的浏览量
        Map<String, Integer> viewCountMap = redisCache.getCacheMap("article:viewCount");

        List<Article> articles = viewCountMap.entrySet()
                .stream()
                .map(entry -> new Article(Long.valueOf(entry.getKey()), entry.getValue().longValue()))
                .collect(Collectors.toList());
        //更新到数据库中
        articleService.updateBatchById(articles);

    }
}

~~~~

##### ④读取文章浏览量时从redis读取

修改一下ArticleServiceImpl的getArticleDetail(Long id)方法

~~~~java
    @Override
    public ResponseResult getArticleDetail(Long id) {
        //根据id查询文章
        Article article = getById(id);
        //从redis中获取viewCount
        Integer viewCount = redisCache.getCacheMapValue("article:viewCount", id.toString());
        article.setViewCount(viewCount.longValue());
        //转换成VO
        ArticleDetailVo articleDetailVo = BeanCopyUtils.copyBean(article, ArticleDetailVo.class);
        //根据分类id查询分类名
        Long categoryId = articleDetailVo.getCategoryId();
        Category category = categoryService.getById(categoryId);
        if(category!=null){
            articleDetailVo.setCategoryName(category.getName());
        }
        //封装响应返回
        return ResponseResult.okResult(articleDetailVo);
    }

~~~~

## Swagger2

**简介**

Swagger 是一套基于 OpenAPI 规范构建的开源工具，可以帮助我们设计、构建、记录以及使用Rest API。

**为什么使用Swagger**

前后端分离的开发模式中，前端和后端的工作由不同的工程师完成。在这种开发模式下，维持一份及时更新且完整的Rest API 文档将会极大的提高工作效率。

传统意义上的文档都是后端开发人员手动编写的。这种方式很难保证文档的及时性，久而久之也就会失去其参考意义，反而还会加大沟通成本。

而Swagger提供了一个全新的维护API文档的方式

1. 代码变，文档变。只需要少量的注解，Swagger 就可以根据代码自动生成 API文档，很好的保证了文档的时效性。
2. 跨语言性，支持 40 多种语言。
3. Swagger UI呈现出来的是一份可交互式的API文档。我们可以直接在文档页面尝试 API 的调用，省去了准备复杂的调用参数的过程。

### 快速入门

#### 引入依赖

~~~~xml
        <dependency>
            <groupId>io.springfox</groupId>
            <artifactId>springfox-swagger2</artifactId>
        </dependency>
        <dependency>
            <groupId>io.springfox</groupId>
            <artifactId>springfox-swagger-ui</artifactId>
        </dependency>

~~~~

#### 启用Swagger2

在启动类上或者配置类加@EnableSwagger2 注解

~~~~java
@SpringBootApplication
@MapperScan("com.xiaored.mapper")
@EnableScheduling
@EnableSwagger2
public class XiaoRedBlogApplication {

    public static void main(String[] args) {
        SpringApplication.run(XiaoRedBlogApplication.class,args);
    }
}
~~~~

#### 访问文档

访问：http://localhost:7777/swagger-ui.html  

注意其中localhost和7777要调整成实际项目的域名和端口号。

### 具体配置

#### Controller配置

**@Api注解**

属性介绍：

tags  设置标签

description 设置描述信息

~~~~java
@RestController
@RequestMapping("/comment")
@Api(tags = "评论",description = "评论相关接口")
public class CommentController {
}
~~~~

#### 接口配置（controller里面的handler方法）

**@ApiOperation接口描述**

~~~~java
    @GetMapping("/linkCommentList")
    @ApiOperation(value = "友链评论列表",notes = "获取一页友链评论")
    public ResponseResult linkCommentList(Integer pageNum,Integer pageSize){
        return commentService.commentList(SystemConstants.LINK_COMMENT,null,pageNum,pageSize);
    }
~~~~

**@ApiImplicitParams接口参数描述**

 @ApiImplicitParam 用于描述接口的参数，但是一个接口可能有多个参数，所以一般与 @ApiImplicitParams 组合使用。

~~~~java
    @GetMapping("/linkCommentList")
    @ApiOperation(value = "友链评论列表",notes = "获取一页友链评论")
    @ApiImplicitParams({
           @ApiImplicitParam(name = "pageNum",value = "页号"),
           @ApiImplicitParam(name = "pageSize",value = "每页大小")
    }
    )
    public ResponseResult linkCommentList(Integer pageNum,Integer pageSize){
        return commentService.commentList(SystemConstants.LINK_COMMENT,null,pageNum,pageSize);
    }
~~~~

#### 实体类配置

**@ApiModel配置实体的描述**

~~~~java
@Data
@AllArgsConstructor
@NoArgsConstructor
@ApiModel(description = "添加评论dto")
public class AddCommentDto{
    //..
}
~~~~

**@ApiModelProperty描述实体的属性**

~~~~java
    @ApiModelProperty(notes = "评论类型（0代表文章评论，1代表友链评论）")
    private String type;
~~~~


#### 文档信息配置

希望前台有一个对应文档，后台有一个对应文档

因此文档信息配置要分在不同模块

**前台模块**

~~~~java
@Configuration
public class SwaggerConfig {
    @Bean
    public Docket customDocket() {
        return new Docket(DocumentationType.SWAGGER_2)
                .apiInfo(apiInfo())
                .select()
                .apis(RequestHandlerSelectors.basePackage("com.xiaored.controller"))
                .build();
    }

    private ApiInfo apiInfo() {
        Contact contact = new Contact("团队名", "http://www.my.com", "my@my.com");//团队名，网址，邮箱
        return new ApiInfoBuilder()
                .title("文档标题")
                .description("文档描述")
                .contact(contact)   // 联系方式
                .version("1.1.0")  // 版本
                .build();
    }
}
~~~~

## 博客后台

### 准备工作

前端工程启动

```
npm install

npm run dev
```

①创建启动类

~~~~java
@SpringBootApplication
@MapperScan("com.xiaored.mapper")
public class BlogAdminApplication {
    public static void main(String[] args) {
        SpringApplication.run(BlogAdminApplication.class, args);
    }
}
~~~~

②创建application.yml配置文件

~~~~yml
server:
  port: 8989
spring:
  datasource:
    url: jdbc:mysql://localhost:3306/xhr_blog?characterEncoding=utf-8&serverTimezone=Asia/Shanghai
    username: root
    password: cronaldo7
    driver-class-name: com.mysql.cj.jdbc.Driver
  servlet:
    multipart:
      max-file-size: 2MB
      max-request-size: 5MB

mybatis-plus:
  configuration:
    # 日志
    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl
  global-config:
    db-config:
      logic-delete-field: delFlag
      logic-delete-value: 1
      logic-not-delete-value: 0
      id-type: auto
~~~~

③ SQL语句

SQL脚本：前后端分离博客系统\资源\SQL\xhr_tag.sql

④ 用easycode创建xhr_tag表的对应实体类，Mapper，Service，ServiceImpl

**写在公共模块中**

⑤ 在**后台模块**创建Controller测试接口

TagController    /content/tag

~~~~java
@RestController
@RequestMapping("/content/tag")
public class TagController {
    @Autowired
    private TagService tagService;

    @GetMapping("/list")
    public ResponseResult list(){
        return ResponseResult.okResult(tagService.list());
    }
}


~~~~

⑥**后台模块**添加security相关类

*注：以下这两个直接复制前台模块中对应的这两个类，然后做点小改动就行*

com/xiaored/config/SecurityConfig.java

现在暂时放开所有接口

~~~~java
@Configuration
public class SecurityConfig extends WebSecurityConfigurerAdapter {

    @Override
    @Bean
    public AuthenticationManager authenticationManagerBean() throws Exception {
        return super.authenticationManagerBean();
    }

    @Autowired
    private JwtAuthenticationTokenFilter jwtAuthenticationTokenFilter;
    @Autowired
    AuthenticationEntryPoint authenticationEntryPoint;
    @Autowired
    AccessDeniedHandler accessDeniedHandler;


    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
                //关闭csrf
                .csrf().disable()
                //不通过Session获取SecurityContext
                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)
                .and()
                .authorizeRequests()
                 //对于登录接口 允许匿名访问
                .antMatchers("/login").anonymous()
                // 除上面外的所有请求全部不需要认证即可访问
                .anyRequest().authenticated();

        //配置异常处理器
        http.exceptionHandling()
                .authenticationEntryPoint(authenticationEntryPoint)
                .accessDeniedHandler(accessDeniedHandler);
        //关闭默认的注销功能
        http.logout().disable();
        //把jwtAuthenticationTokenFilter添加到SpringSecurity的过滤器链中
        http.addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class);
        //允许跨域
        http.cors();
    }

    @Bean
    public PasswordEncoder passwordEncoder(){
        return new BCryptPasswordEncoder();
    }
}
~~~~

com/xiaored/filter/JwtAuthenticationTokenFilter.java

和前台区别：

"bloglogin"改成"login"

```java
LoginUser loginUser = redisCache.getCacheObject("login:" + userId);
```

~~~~java
@Component
public class JwtAuthenticationTokenFilter extends OncePerRequestFilter {

    @Autowired
    private RedisCache redisCache;

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {
        //获取请求头中的token
        String token = request.getHeader("token");
        if(!StringUtils.hasText(token)){
            //说明该接口不需要登录  直接放行
            filterChain.doFilter(request, response);
            return;
        }
        //解析获取userid
        Claims claims = null;
        try {
            claims = JwtUtil.parseJWT(token);
        } catch (Exception e) {
            e.printStackTrace();
            //token超时  token非法
            //响应告诉前端需要重新登录
            ResponseResult result = ResponseResult.errorResult(AppHttpCodeEnum.NEED_LOGIN);
            WebUtils.renderString(response, JSON.toJSONString(result));
            return;
        }
        String userId = claims.getSubject();
        //从redis中获取用户信息
        LoginUser loginUser = redisCache.getCacheObject("login:" + userId);
        //如果获取不到
        if(Objects.isNull(loginUser)){
            //说明登录过期  提示重新登录
            ResponseResult result = ResponseResult.errorResult(AppHttpCodeEnum.NEED_LOGIN);
            WebUtils.renderString(response, JSON.toJSONString(result));
            return;
        }
        //存入SecurityContextHolder
        UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(loginUser,null,null);
        SecurityContextHolder.getContext().setAuthentication(authenticationToken);

        filterChain.doFilter(request, response);
    }
}

~~~~

### 后台登录

后台的认证授权也使用SpringSecurity安全框架来实现。

#### 需求

需要实现登录功能

后台所有功能都必须登录才能使用。

#### 接口设计

| 请求方式 | 请求路径    |
| -------- | ----------- |
| POST     | /user/login |

请求体：

~~~~json
{
    "userName":"sg",
    "password":"1234"
}
~~~~

响应格式：

~~~~json
{
    "code": 200,
    "data": {
        "token": "eyJhbGciOiJIUzI1NiJ9.eyJqdGkiOiI0ODBmOThmYmJkNmI0NjM0OWUyZjY2NTM0NGNjZWY2NSIsInN1YiI6IjEiLCJpc3MiOiJzZyIsImlhdCI6MTY0Mzg3NDMxNiwiZXhwIjoxNjQzOTYwNzE2fQ.ldLBUvNIxQCGemkCoMgT_0YsjsWndTg5tqfJb77pabk"
    },
    "msg": "操作成功"
}
~~~~

#### 表分析

还是使用sys_user

#### 思路分析

*登录*

​①自定义登录接口  

 调用ProviderManager的方法进行认证 如果认证通过生成jwt

 把用户信息存入redis中

②自定义UserDetailsService 

 在这个实现类中去查询数据库

 注意配置passwordEncoder为BCryptPasswordEncoder

*校验*

​​①定义Jwt认证过滤器
  1. ​获取token
  2. ​解析token获取其中的userid
  3. ​从redis中获取用户信息
  4. 封装Authentication对象​存入SecurityContextHolder

#### 准备工作

①添加redis依赖,fastjson依赖,jwt依赖(都已经加好了，不用管了)

②工具类和相关配置类（之前都已经加好了，不用管了）

#### 登录接口代码实现

##### AdminLoginController

复制前台模块的BlogLoginController，命名为AdminLoginController，其中注入 AdminLoginService 

请求地址修改为/user/login即可

~~~~java
@RestController
public class AdminLoginController {
    @Autowired
    private AdminLoginService adminLoginService;

    @PostMapping("/user/login")
    public ResponseResult login(@RequestBody User user){
        if(!StringUtils.hasText(user.getUserName())){
            //提示 必须要传用户名
            throw new SystemException(AppHttpCodeEnum.REQUIRE_USERNAME);
        }
        return adminLoginService.login(user);
    }
}
~~~~

##### AdminLoginService

复制BlogLoginService命名为AdminLoginService即可

~~~~java
public interface AdminLoginService {
    ResponseResult login(User user);
}
~~~~

##### SecurityConfig

之前已经复制过了,但要完善校验功能的配置

改动：

1. 放行登录接口，路径是"/user/login"
2. permitAll()改为authenticated()表示其他所有请求都要认证后才可访问

```java
.antMatchers("/user/login").anonymous()
// 除上面外的所有请求都要认证后才可访问
.anyRequest().authenticated();
```

即

```java
@Override
    protected void configure(HttpSecurity http) throws Exception {
        http
                //关闭csrf
                .csrf().disable()
                //不通过Session获取SecurityContext
                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)
                .and()
                .authorizeRequests()
                 //对于登录接口 允许匿名访问
                .antMatchers("/user/login").anonymous()
                // 除上面外的所有请求全部不需要认证即可访问
                .anyRequest().authenticated();
```

##### AdminLoginServiceImpl

复制一份LoginServiceImpl，命名为SystemLoginServiceImpl实现AdminLoginService

* login方法中存redis的key的前缀修改为login
* 返回的数据中只需要返回token，不用返回UserInfoVo了
* logout注销接口还没实现，先删掉

~~~~java
@Service
public class AdminLoginServiceImpl implements AdminLoginService {

    @Autowired
    private AuthenticationManager authenticationManager;

    @Autowired
    private RedisCache redisCache;

    @Override
    public ResponseResult login(User user) {
        UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(user.getUserName(),user.getPassword());
        Authentication authenticate = authenticationManager.authenticate(authenticationToken);
        //判断是否认证通过
        if(Objects.isNull(authenticate)){
            throw new RuntimeException("用户名或密码错误");
        }
        //获取userid 生成token
        LoginUser loginUser = (LoginUser) authenticate.getPrincipal();
        String userId = loginUser.getUser().getId().toString();
        String jwt = JwtUtil.createJWT(userId);
        //把用户信息存入redis
        redisCache.setCacheObject("login:"+userId,loginUser);

        //把token封装 返回
		Map<String,String> map = new HashMap<>();
        map.put("token",jwt);
        return ResponseResult.okResult(map);
    }
}
~~~~

##### UserDetailServiceImpl

复用原来的即可

##### LoginUser

复用原来的即可


### 后台权限控制及动态路由

#### 需求

后台系统需要实现不同的用户权限可以看到不同的功能。

用户只能使用他的权限所允许使用的功能。

#### 功能设计

在**RBAC权限模型**的基础上去实现这个功能。

#### 表分析

建表SQL及初始化数据见：前后端分离博客系统\资源\SQL\xhr_menu.sql

通过需求去分析需要有哪些字段

xhr_menu，sys_role,sys_role_menu,sys_role_user表

得到用户id，去sys_role_user表里查对应的角色id，然后去sys_role表里得到role_key

得到用户id，去sys_role_user表里查对应的角色id，然后去sys_role_menu表里得到对应menu的id，然后去xhr_menu里查找menu

#### 接口设计

##### getInfo接口

是

| 请求方式 | 请求地址 | 请求头          |
| -------- | -------- | --------------- |
| GET      | /getInfo | 需要token请求头 |

请求参数：

无

响应格式:

如果用户id为1代表管理员，roles 中只需要有admin，permissions中需要有所有菜单类型为C或者F的，状态为正常的，未被删除的权限

~~~~json
{
	"code":200,
	"data":{
		"permissions":[
			"system:user:list",
            "system:role:list",
			"system:menu:list",
			"system:user:query",
			"system:user:add"
            //此次省略1000字
		],
		"roles":[
			"admin"
		],
		"user":{
			"avatar":"http://r7yxkqloa.bkt.clouddn.com/2022/03/05/75fd15587811443a9a9a771f24da458d.png",
			"email":"23412332@qq.com",
			"id":1,
			"nickName":"sg3334",
			"sex":"1"
		}
	},
	"msg":"操作成功"
}
~~~~

##### getRouters接口

| 请求方式 | 请求地址    | 请求头          |
| -------- | ----------- | --------------- |
| GET      | /getRouters | 需要token请求头 |

请求参数：

无

响应格式:

前端为了实现动态路由的效果，需要后端有接口能返回用户所能访问的菜单数据。

注意：**返回的菜单数据需要体现父子菜单的层级关系**

如果用户id为1代表管理员，menus中需要有所有菜单类型为C或者M的，状态为正常的，未被删除的权限

数据格式如下：

~~~~json
{
	"code":200,
	"data":{
		"menus":[
			{
				"children":[],
				"component":"content/article/write/index",
				"createTime":"2022-01-08 11:39:58",
				"icon":"build",
				"id":2023,
				"menuName":"写博文",
				"menuType":"C",
				"orderNum":"0",
				"parentId":0,
				"path":"write",
				"perms":"content:article:writer",
				"status":"0",
				"visible":"0"
			},
			{
				"children":[
					{
						"children":[],
						"component":"system/user/index",
						"createTime":"2021-11-12 18:46:19",
						"icon":"user",
						"id":100,
						"menuName":"用户管理",
						"menuType":"C",
						"orderNum":"1",
						"parentId":1,
						"path":"user",
						"perms":"system:user:list",
						"status":"0",
						"visible":"0"
					},
					{
						"children":[],
						"component":"system/role/index",
						"createTime":"2021-11-12 18:46:19",
						"icon":"peoples",
						"id":101,
						"menuName":"角色管理",
						"menuType":"C",
						"orderNum":"2",
						"parentId":1,
						"path":"role",
						"perms":"system:role:list",
						"status":"0",
						"visible":"0"
					},
					{
						"children":[],
						"component":"system/menu/index",
						"createTime":"2021-11-12 18:46:19",
						"icon":"tree-table",
						"id":102,
						"menuName":"菜单管理",
						"menuType":"C",
						"orderNum":"3",
						"parentId":1,
						"path":"menu",
						"perms":"system:menu:list",
						"status":"0",
						"visible":"0"
					}
				],
				"createTime":"2021-11-12 18:46:19",
				"icon":"system",
				"id":1,
				"menuName":"系统管理",
				"menuType":"M",
				"orderNum":"1",
				"parentId":0,
				"path":"system",
				"perms":"",
				"status":"0",
				"visible":"0"
			}
		]
	},
	"msg":"操作成功"
}
~~~~

#### 代码实现

##### 准备工作

easycode生成sys_menu和sys_role表对应的实体类，mapper，service，serviceImpl

##### getInfo接口

**后台模块**

~~~~java
@RestController
public class AdminLoginController {
    @Autowired
    private AdminLoginService adminLoginService;

    @Autowired
    private MenuService menuService;

    @Autowired
    private RoleService roleService;

    @PostMapping("/user/login")
    public ResponseResult login(@RequestBody User user){
        if(!StringUtils.hasText(user.getUserName())){
            //提示 必须要传用户名
            throw new SystemException(AppHttpCodeEnum.REQUIRE_USERNAME);
        }
        return adminLoginService.login(user);
    }

    @GetMapping("getInfo")
    public ResponseResult<AdminUserInfoVo> getInfo(){
        //获取当前登录的用户
        LoginUser loginUser = SecurityUtils.getLoginUser();
        //根据用户id查询权限信息
        List<String> perms = menuService.selectPermsByUserId(loginUser.getUser().getId());
        //根据用户id查询角色信息
        List<String> roleKeyList = roleService.selectRoleKeyByUserId(loginUser.getUser().getId());

        //获取用户信息
        User user = loginUser.getUser();
        UserInfoVo userInfoVo = BeanCopyUtils.copyBean(user, UserInfoVo.class);
        //封装数据返回

        AdminUserInfoVo adminUserInfoVo = new AdminUserInfoVo(perms,roleKeyList,userInfoVo);
        return ResponseResult.okResult(adminUserInfoVo);
    }

}
~~~~

**公共模块**

```java
@Data
@Accessors(chain = true)
@AllArgsConstructor
@NoArgsConstructor
public class AdminUserInfoVo {

    private List<String> permissions;

    private List<String> roles;

    private UserInfoVo user;
}
```

MenuServiceImpl

selectPermsByUserId方法

~~~~java
@Service("menuService")
public class MenuServiceImpl extends ServiceImpl<MenuMapper, Menu> implements MenuService {

    @Override
    public List<String> selectPermsByUserId(Long id) {
        //如果是管理员，返回所有的权限
        if(id == 1L){
            LambdaQueryWrapper<Menu> wrapper = new LambdaQueryWrapper<>();
            wrapper.in(Menu::getMenuType,SystemConstants.MENU,SystemConstants.BUTTON);
            wrapper.eq(Menu::getStatus,SystemConstants.STATUS_NORMAL);
            List<Menu> menus = list(wrapper);
            List<String> perms = menus.stream()
                    .map(Menu::getPerms)
                    .collect(Collectors.toList());
            return perms;
        }
        //否则返回所具有的权限
        return getBaseMapper().selectPermsByUserId(id);
    }
}
~~~~

SystemConstants类中添加两个常量：

```java
public static final String MENU = "C";
public static final String BUTTON = "F";
```

MenuMapper 

~~~~java
/**
 * 菜单权限表(Menu)表数据库访问层
 *
 * @author makejava
 * @since 2022-08-09 22:32:07
 */
public interface MenuMapper extends BaseMapper<Menu> {

    List<String> selectPermsByUserId(Long userId);
}
~~~~

~~~~xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" >
<mapper namespace="com.xiaored.mapper.MenuMapper">

    <select id="selectPermsByUserId" resultType="java.lang.String">
        SELECT
            DISTINCT m.perms
        FROM
            `sys_user_role` ur
            LEFT JOIN `sys_role_menu` rm ON ur.`role_id` = rm.`role_id`
            LEFT JOIN `sys_menu` m ON m.`id` = rm.`menu_id`
        WHERE
            ur.`user_id` = #{userId} AND
            m.`menu_type` IN ('C','F') AND
            m.`status` = 0 AND
            m.`del_flag` = 0
    </select>
</mapper>
~~~~

RoleServiceImpl

selectRoleKeyByUserId方法

~~~~java
@Service("roleService")
public class RoleServiceImpl extends ServiceImpl<RoleMapper, Role> implements RoleService {

    @Override
    public List<String> selectRoleKeyByUserId(Long id) {
        //判断是否是管理员 如果是返回集合中只需要有admin
        if(id == 1L){
            List<String> roleKeys = new ArrayList<>();
            roleKeys.add("admin");
            return roleKeys;
        }
        //否则查询用户所具有的角色信息
        return getBaseMapper().selectRoleKeyByUserId(id);
    }
}
~~~~

~~~~java
public interface RoleMapper extends BaseMapper<Role> {

    List<String> selectRoleKeyByUserId(Long userId);
}
~~~~

~~~~xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" >
<mapper namespace="com.xiaored.mapper.RoleMapper">
    <select id="selectRoleKeyByUserId" resultType="java.lang.String">
        SELECT
            r.`role_key`
        FROM
            `sys_user_role` ur
            LEFT JOIN `sys_role` r ON ur.`role_id` = r.`id`
        WHERE
            ur.`user_id` = #{userId} AND
            r.`status` = 0 AND
            r.`del_flag` = 0
    </select>
</mapper>
~~~~


##### getRouters接口（重要！！！）

**后台模块**

AdminLoginController

~~~~java
    @GetMapping("getRouters")
    public ResponseResult<RoutersVo> getRouters(){
        Long userId = SecurityUtils.getUserId();
        //查询menu 结果是tree的形式
        List<Menu> menus = menuService.selectRouterMenuTreeByUserId(userId);
        //封装数据返回
        return ResponseResult.okResult(new RoutersVo(menus));
    }
~~~~

**公共模块**

Menu类

 * 添加@Accessors(chain = true)使其可以使用链式编程（这个是写到后面要用到才加的）

 * 类中添加children属性，并告诉mp这个属性不在数据库中，不用去查：

```java
 @TableField(exist = false)
 private List<Menu> children;
```

RoutersVo

~~~~java
@Data
@AllArgsConstructor
@NoArgsConstructor
public class RoutersVo {

    private List<Menu> menus;
}
~~~~

MenuService

~~~~java
public interface MenuService extends IService<Menu> {

    List<String> selectPermsByUserId(Long id);

    List<Menu> selectRouterMenuTreeByUserId(Long userId);
}
~~~~

MenuServiceImpl

~~~~java
@Override
    public List<Menu> selectRouterMenuTreeByUserId(Long userId) {
        MenuMapper menuMapper = getBaseMapper();
        List<Menu> menus = null;
        //判断是否是管理员
        if(SecurityUtils.isAdmin()){
            //如果是 获取所有符合要求的Menu
            menus = menuMapper.selectAllRouterMenu();
        }else{
            //否则  获取当前用户所具有的Menu
            menus = menuMapper.selectRouterMenuTreeByUserId(userId);
        }

        //上述获得的menus都是没有chuldren属性的
        //构建tree：实际上就是给menus中的每个menu对象的children属性赋值
        //递归：先找出第一层的菜单（第一个传入parentId=0L），然后去找他们的子菜单设置到children属性中
        List<Menu> menuTree = builderMenuTree(menus,0L);
        return menuTree;
    }

    private List<Menu> builderMenuTree(List<Menu> menus, Long parentId) {
        List<Menu> menuTree = menus.stream()
                .filter(menu -> menu.getParentId().equals(parentId))//过滤：筛选出parentId符合传入参数的menu
                .map(menu -> menu.setChildren(getChildren(menu, menus)))//getChildren找到这个菜单的子菜单，设置给children属性
                .collect(Collectors.toList());//将这些设置了children属性的menu收集为一个集合
        return menuTree;
    }

    /**
     * 获取存入参数的 子Menu集合
     * @param menu
     * @param menus
     * @return
     */
    private List<Menu> getChildren(Menu menu, List<Menu> menus) {
        List<Menu> childrenList = menus.stream()
                .filter(m -> m.getParentId().equals(menu.getId()))//过滤：筛选出menu的子菜单
                .map(m->m.setChildren(getChildren(m,menus)))//递归：设置子菜单的子菜单（递归的出口就是filter()返回null的时候）
                .collect(Collectors.toList());
        return childrenList;
    }
~~~~

MenuMapper.java

~~~~java
    List<Menu> selectAllRouterMenu();

    List<Menu> selectRouterMenuTreeByUserId(Long userId);
~~~~

MenuMapper.xml

~~~~xml
 <select id="selectAllRouterMenu" resultType="com.xiaored.domain.entity.Menu">
        SELECT
          DISTINCT m.id, m.parent_id, m.menu_name, m.path, m.component, m.visible, m.status, IFNULL(m.perms,'') AS perms, m.is_frame,  m.menu_type, m.icon, m.order_num, m.create_time
        FROM
            `sys_menu` m
        WHERE
            m.`menu_type` IN ('C','M') AND
            m.`status` = 0 AND
            m.`del_flag` = 0
        ORDER BY
            m.parent_id,m.order_num
    </select>
    <select id="selectRouterMenuTreeByUserId" resultType="com.xiaored.domain.entity.Menu">
        SELECT
          DISTINCT m.id, m.parent_id, m.menu_name, m.path, m.component, m.visible, m.status, IFNULL(m.perms,'') AS perms, m.is_frame,  m.menu_type, m.icon, m.order_num, m.create_time
        FROM
            `sys_user_role` ur
            LEFT JOIN `sys_role_menu` rm ON ur.`role_id` = rm.`role_id`
            LEFT JOIN `sys_menu` m ON m.`id` = rm.`menu_id`
        WHERE
            ur.`user_id` = #{userId} AND
            m.`menu_type` IN ('C','M') AND
            m.`status` = 0 AND
            m.`del_flag` = 0
        ORDER BY
            m.parent_id,m.order_num
    </select>
~~~~

查询的列：

SELECT DISTINCT m.id, m.parent_id, m.menu_name, m.path, m.component, m.visible, m.status, IFNULL(m.perms,'') AS perms, m.is_frame,  m.menu_type, m.icon, m.order_num, m.create_time

注意需要按照parent_id和order_num排序


### 退出登录接口

#### 接口设计

| 请求方式 | 请求地址     | 请求头          |
| -------- | ------------ | --------------- |
| POST     | /user/logout | 需要token请求头 |

响应格式:

~~~~json
{
    "code": 200,
    "msg": "操作成功"
}
~~~~

#### 代码实现

要实现的操作：删除redis中的用户信息

**后台模块**

AdminLoginController

~~~~java
    @PostMapping("/user/logout")
    public ResponseResult logout(){
        return adminLoginService.logout();
    }
~~~~

**公共模块**

AdminLoginService

~~~~java
ResponseResult logout();
~~~~

SystemLoginServiceImpl

~~~~java
    @Override
    public ResponseResult logout() {
        //获取当前登录的用户id
        Long userId = SecurityUtils.getUserId();
        //删除redis中对应的值
        redisCache.deleteObject(  "login:"+userId);
        return ResponseResult.okResult();
    }
~~~~

SecurityConfig

要关闭默认的退出登录功能。并且要配置我们的退出登录接口需要认证才能访问

~~~~java
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
                //关闭csrf
                .csrf().disable()
                //不通过Session获取SecurityContext
                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)
                .and()
                .authorizeRequests()
                // 对于登录接口 允许匿名访问
                .antMatchers("/user/login").anonymous()
//                //注销接口需要认证才能访问
//                .antMatchers("/logout").authenticated()
//                .antMatchers("/user/userInfo").authenticated()
//                .antMatchers("/upload").authenticated()
                // 除上面外的所有请求全部不需要认证即可访问
                .anyRequest().authenticated();

        //配置异常处理器
        http.exceptionHandling()
                .authenticationEntryPoint(authenticationEntryPoint)
                .accessDeniedHandler(accessDeniedHandler);
        //关闭默认的注销功能
        http.logout().disable();
        //把jwtAuthenticationTokenFilter添加到SpringSecurity的过滤器链中
        http.addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class);
        //允许跨域
        http.cors();
    }
~~~~

### 查询标签列表

#### 需求

为了方便后期对文章进行管理，需要提供标签的功能，一个文章可以有多个标签。

在后台需要分页查询标签功能，要求能**根据标签名进行分页查询**。

**后期可能会增加备注查询等需求**。

注意：不能把删除了的标签查询出来。

#### 标签表分析

通过需求去分析需要有哪些字段。

#### 接口设计

| 请求方式 | 请求路径         |
| -------- | ---------------- |
| Get      | content/tag/list |

Query格式请求参数：

pageNum: 页码

pageSize: 每页条数

name：标签名

remark：备注

响应格式：

~~~~json
{
	"code":200,
	"data":{
		"rows":[
			{
				"id":4,
				"name":"Java",
				"remark":"sdad"
			}
		],
		"total":1
	},
	"msg":"操作成功"
}
~~~~

#### 代码实现

**后台模块**

Controller

~~~~java
@RestController
@RequestMapping("/content/tag")
public class TagController {
    @Autowired
    private TagService tagService;

    @GetMapping("/list")
    public ResponseResult<PageVo> list(Integer pageNum, Integer pageSize, TagListDto tagListDto){
        return tagService.pageTagList(pageNum,pageSize,tagListDto);
    }
}
~~~~

**公共模块**

创建com/xiaored/domain/dto/TagListDto.java

将请求参数name和remark封装为TagListDto

```java
@Data
@AllArgsConstructor
@NoArgsConstructor
public class TagListDto {
    private String name;
    private String remark;
}
```

Service

```java
public interface TagService extends IService<Tag> {

    ResponseResult<PageVo> pageTagList(Integer pageNum, Integer pageSize, TagListDto tagListDto);
}

```

~~~~java
@Service("tagService")
public class TagServiceImpl extends ServiceImpl<TagMapper, Tag> implements TagService {

    @Override
    public ResponseResult<PageVo> pageTagList(Integer pageNum, Integer pageSize, TagListDto tagListDto) {
        //分页查询
        LambdaQueryWrapper<Tag> queryWrapper = new LambdaQueryWrapper<>();
        //注意：传进来的name，remark可能为空，因此先用StringUtils.hasText()判断
        //如果有值，则为true，这个条件会被拼接上去
        //如果没值，则为false，这个条件不会被拼接上去
        queryWrapper.eq(StringUtils.hasText(tagListDto.getName()),Tag::getName,tagListDto.getName());
        queryWrapper.eq(StringUtils.hasText(tagListDto.getRemark()),Tag::getRemark,tagListDto.getRemark());

        Page<Tag> page = new Page<>();
        page.setCurrent(pageNum);
        page.setSize(pageSize);
        page(page, queryWrapper);
        //封装数据返回
        PageVo pageVo = new PageVo(page.getRecords(),page.getTotal());
        return ResponseResult.okResult(pageVo);
    }
}
~~~~

### 新增标签

#### 需求

点击标签管理的新增按钮可以实现新增标签的功能。

#### 接口设计

| 请求方式 | 请求地址     | 请求头          |
| -------- | ------------ | --------------- |
| POST     | /content/tag | 需要token请求头 |

请求体格式:

~~~~json
{"name":"c#","remark":"c++++"}
~~~~

响应格式：

~~~~json
{
	"code":200,
	"msg":"操作成功"
}
~~~~

#### 代码实现

TagController

```java
@PostMapping
    public ResponseResult addTag(@RequestBody Tag tag){
        return tagService.addTag(tag);
    }
```

TagServiceImpl

```java
@Override
    public ResponseResult addTag(Tag tag) {
        //标签名不能为空
        if(!StringUtils.hasText(tag.getName())){
            throw new SystemException(AppHttpCodeEnum.TAGNAME_NOT_NULL);
        }
        save(tag);
        return ResponseResult.okResult();
    }
```

```java
TAGNAME_NOT_NULL(513,"标签名不能为空" );
```

Tag实体类字段自动填充（MybatisHandler之前写过了）

```java
    @TableField(fill = FieldFill.INSERT)
    private Long createBy;
    @TableField(fill = FieldFill.INSERT)
    private Date createTime;
    @TableField(fill = FieldFill.INSERT_UPDATE)
    private Long updateBy;
    @TableField(fill = FieldFill.INSERT_UPDATE)
    private Date updateTime;
```

### 删除标签

注意：只是逻辑删除

#### 接口设计 

| 请求方式 | 请求地址          | 请求头          |
| -------- | ----------------- | --------------- |
| DELETE   | /content/tag/{id} | 需要token请求头 |

请求参数在path中

例如：content/tag/6   代表删除id为6的标签数据

响应格式：

~~~~json
{
	"code":200,
	"msg":"操作成功"
}
~~~~

#### 代码实现

TagController

```java
@DeleteMapping("/{id}")
    public ResponseResult deleteTag(@PathVariable("id") Long id){return tagService.deleteById(id);}
```

TagServiceImpl

```java
@Resource
    TagMapper tagMapper;
@Override
    public ResponseResult deleteById(Long id) {
        if(tagMapper.deleteById(id)==0){
            throw new SystemException(AppHttpCodeEnum.SYSTEM_ERROR);
        }
        else
            return ResponseResult.okResult();
    }
```

### 修改标签

#### 接口设计

##### 获取标签信息接口

| 请求方式 | 请求地址          | 请求头          |
| -------- | ----------------- | --------------- |
| GET      | /content/tag/{id} | 需要token请求头 |

请求参数在path中

例如：content/tag/6   代表获取id为6的标签数据

响应格式：

~~~~json
{
	"code":200,
	"data":{
        "id":4,
        "name":"Java",
        "remark":"sdad"
	},
	"msg":"操作成功"
}
~~~~

##### 修改标签接口

| 请求方式 | 请求地址     | 请求头          |
| -------- | ------------ | --------------- |
| PUT      | /content/tag | 需要token请求头 |

请求体格式：

~~~~json
{"id":7,"name":"c#","remark":"c++++"}
~~~~



响应格式：

~~~~json
{
	"code":200,
	"msg":"操作成功"
}
~~~~

#### 代码实现

TagController

```java
  @GetMapping({"/{id}"})
    public ResponseResult<TagInfoVo> getTagInfo(@PathVariable("id") Long id){return tagService.getTagInfoById(id);}

    @PutMapping()
    public ResponseResult updateTagInfo(@RequestBody Tag tag){return tagService.updateInfo(tag);}
```

TagInfoVo

```java
@Data
@AllArgsConstructor
@NoArgsConstructor
public class TagInfoVo  {
    private Long id;
    //标签名
    private String name;
    //备注
    private String remark;
}
```

TagServiceImpl

```java
@Override
    public ResponseResult<TagInfoVo> getTagInfoById(Long id) {
        Tag tag=getById(id);
        //转换成VO
        TagInfoVo tagInfoVo= BeanCopyUtils.copyBean(tag, TagInfoVo.class);
        //封装响应返回
        return ResponseResult.okResult(tagInfoVo);
    }

    @Override
    public ResponseResult updateInfo(Tag tag) {
        if(tagMapper.updateById(tag)==0){
            throw new SystemException(AppHttpCodeEnum.SYSTEM_ERROR);
        }
        return ResponseResult.okResult();
    }
```

之前写的MyMetaObjectHandler没有自动填充"updateBy",小改一下

```java
@Override
    public void updateFill(MetaObject metaObject) {
        Long userId = null;
        try {
            userId = SecurityUtils.getUserId();
        } catch (Exception e) {
            e.printStackTrace();
            userId = -1L;//表示是自己创建
        }
        this.setFieldValByName("updateTime", new Date(), metaObject);
        this.setFieldValByName("updateBy", userId, metaObject);
        this.setFieldValByName(" ", SecurityUtils.getUserId(), metaObject);
    }
```

### 写博文

#### 需求

需要提供写博文的功能，写博文时需要关联分类和标签。

文章对分类是一对一的，文章对标签是一对多的

可以上传缩略图，也可以在正文中添加图片。

文章可以直接发布，也可以保存到草稿箱。

#### 表分析

SQL脚本：前后端分离博客系统\资源\SQL\xhr_article_tag.sql

标签和文章需要关联所以需要一张关联表。

#### 接口设计

思考下需要哪些接口才能实现这个功能？

##### 查询所有分类接口

| 请求方式 | 请求地址                          | 请求头          |
| -------- | --------------------------------- | --------------- |
| GET      | /content/category/listAllCategory | 需要token请求头 |

请求参数：无

响应格式：

~~~~json
{
	"code":200,
	"data":[
		{
			"description":"wsd",
			"id":1,
			"name":"java"
		},
		{
			"description":"wsd",
			"id":2,
			"name":"PHP"
		}
	],
	"msg":"操作成功"
}
~~~~

##### 查询所有标签接口

| 请求方式 | 请求地址                | 请求头          |
| -------- | ----------------------- | --------------- |
| GET      | /content/tag/listAllTag | 需要token请求头 |

请求参数:无

响应格式：

~~~~json
{
	"code":200,
	"data":[
		{
			"id":1,
			"name":"Mybatis"
		},
		{
			"id":4,
			"name":"Java"
		}
	],
	"msg":"操作成功"
}
~~~~

##### 上传图片

| 请求方式 | 请求地址 | 请求头          |
| -------- | -------- | --------------- |
| POST     | /upload  | 需要token请求头 |

参数：img,值为要上传的文件

请求头：

Content-Type ：multipart/form-data;

响应格式:

~~~~json
{
    "code": 200,
    "data": "文件访问链接",
    "msg": "操作成功"
}
~~~~

##### 新增博文

添加到草稿箱也是在这个接口，因为发布和草稿只是文章的status属性不一样而已

| 请求方式 | 请求地址         | 请求头          |
| -------- | ---------------- | --------------- |
| POST     | /content/article | 需要token请求头 |

请求体格式：

~~~~json
{
    "title":"测试新增博文",
    "thumbnail":"https://sg-blog-oss.oss-cn-beijing.aliyuncs.com/2022/08/21/4ceebc07e7484beba732f12b0d2c43a9.png",
    "isTop":"0",
    "isComment":"0",
    "content":"# 一级标题\n## 二级标题\n![Snipaste_20220228_224837.png](https://sg-blog-oss.oss-cn-beijing.aliyuncs.com/2022/08/21/c3af554d4a0f4935b4073533a4c26ee8.png)\n正文",
    "tags":[
        1,
        4
    ],
    "categoryId":1,
    "summary":"哈哈",
    "status":"1"
}
~~~~

响应格式：

~~~~json
{
	"code":200,
	"msg":"操作成功"
}
~~~~

#### 代码实现

##### 查询所有分类接口

CategoryController

~~~~java
@RestController
@RequestMapping("/content/category")
public class CategoryController {
    @Autowired
    private CategoryService categoryService;
    
    @GetMapping("/listAllCategory")
    public ResponseResult listAllCategory(){
        List<CategoryVo> list = categoryService.listAllCategory();
        return ResponseResult.okResult(list);
    }  
}
~~~~

CategoryVo修改,增加description属性

~~~~java
@Data
@NoArgsConstructor
@AllArgsConstructor
public class CategoryVo {

    private Long id;
    private String name;
    //描述
    private String description;
}
~~~~

CategoryService增加listAllCategory方法

~~~~java
public interface CategoryService extends IService<Category> {


    ResponseResult getCategoryList();

    List<CategoryVo> listAllCategory();
}

~~~~

SystemConstants中增加常量

~~~~java
    /** 正常状态 */
    public static final String NORMAL = "0";
~~~~

CategoryServiceImpl增加方法

~~~~java
    @Override
    public List<CategoryVo> listAllCategory() {
        LambdaQueryWrapper<Category> wrapper = new LambdaQueryWrapper<>();
        wrapper.eq(Category::getStatus, SystemConstants.NORMAL);
        List<Category> list = list(wrapper);
        List<CategoryVo> categoryVos = BeanCopyUtils.copyBeanList(list, CategoryVo.class);
        return categoryVos;
    }
~~~~

##### 查询所有标签接口

TagVo

~~~~java
@Data
@AllArgsConstructor
@NoArgsConstructor
public class TagVo {
    private Long id;

    //标签名
    private String name;
}
~~~~

TagController

~~~~java
    @GetMapping("/listAllTag")
    public ResponseResult listAllTag(){
        List<TagVo> list = tagService.listAllTag();
        return ResponseResult.okResult(list);
    }
~~~~

TagService 增加listAllTag方法

~~~~java
List<TagVo> listAllTag();
~~~~

TagServiceImpl

~~~~java
    @Override
    public List<TagVo> listAllTag() {
        LambdaQueryWrapper<Tag> wrapper = new LambdaQueryWrapper<>();
        wrapper.select(Tag::getId,Tag::getName);
        List<Tag> list = list(wrapper);
        List<TagVo> tagVos = BeanCopyUtils.copyBeanList(list, TagVo.class);
        return tagVos;
    }
~~~~

##### 上传图片接口

在**后台模块**中增加UploadController

~~~~java
@RestController
public class UploadController {

    @Autowired
    private UploadService uploadService;

    @PostMapping("/upload")
    public ResponseResult uploadImg(@RequestParam("img") MultipartFile multipartFile) {
        try {
            return uploadService.uploadImg(multipartFile);
        } catch (IOException e) {
            e.printStackTrace();
            throw new RuntimeException("文件上传上传失败");
        }
    }
}
~~~~

##### 新增博文接口

ArticleController

关联关系保存

~~~~java
@RestController
@RequestMapping("/content/article")
public class ArticleController {

    @Autowired
    private ArticleService articleService;

    @PostMapping
    public ResponseResult add(@RequestBody AddArticleDto article){
        return articleService.add(article);
    }
}
~~~~

AddArticleDto

注意：增加tags属性用于接收文章关联标签的id

~~~~java
@Data
@AllArgsConstructor
@NoArgsConstructor
public class AddArticleDto {

    private Long id;
    //标题
    private String title;
    //文章内容
    private String content;
    //文章摘要
    private String summary;
    //所属分类id
    private Long categoryId;

    //缩略图
    private String thumbnail;
    //是否置顶（0否，1是）
    private String isTop;
    //状态（0已发布，1草稿）
    private String status;
    //访问量
    private Long viewCount;
    //是否允许评论 1是，0否
    private String isComment;
    //文章关联标签的id
    private List<Long> tags;
}
~~~~

Article 

属性自动填充

~~~~java
    @TableField(fill = FieldFill.INSERT)
    private Long createBy;
    @TableField(fill = FieldFill.INSERT)
    private Date createTime;
    @TableField(fill = FieldFill.INSERT_UPDATE)
    private Long updateBy;
    @TableField(fill = FieldFill.INSERT_UPDATE)
    private Date updateTime;
~~~~

ArticleService增加方法

~~~~java
ResponseResult add(AddArticleDto article);
~~~~

easycode创建xhr_article_tag表相关的实体类，mapper，service,serviceimpl等

```java
@TableName(value="xhr_article_tag")
@Data
@AllArgsConstructor
@NoArgsConstructor
public class ArticleTag implements Serializable {
    private static final long serialVersionUID = 625337492348897098L;
    
    /**
    * 文章id
    */
    private Long articleId;
    /**
    * 标签id
    */
    private Long tagId;
}
```

ArticleServiceImpl增加如下代码

~~~~java
    @Autowired
    private ArticleTagService articleTagService;

    @Override
    @Transactional
    public ResponseResult add(AddArticleDto articleDto) {
        //添加 博客
        Article article = BeanCopyUtils.copyBean(articleDto, Article.class);
        save(article);


        List<ArticleTag> articleTags = articleDto.getTags().stream()
                .map(tagId -> new ArticleTag(article.getId(), tagId))
                .collect(Collectors.toList());

        //添加 博客和标签的关联
        articleTagService.saveBatch(articleTags);
        return ResponseResult.okResult();
    }
~~~~

### 导出所有分类到Excel

#### 需求

在分类管理中点击导出按钮可以把所有的分类导出到Excel文件中。

#### 看EasyExcel文档

使用EasyExcel实现Excel的导出操作。

https://github.com/alibaba/easyexcel

https://easyexcel.opensource.alibaba.com/docs/current/quickstart/write#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81-1

#### 接口设计

| 请求方式 | 请求地址                 | 请求头          |
| -------- | ------------------------ | --------------- |
| GET      | /content/category/export | 需要token请求头 |

请求参数：无

响应格式：

成功的话可以直接导出一个Excel文件

失败的话响应格式如下：

~~~~json
{
	"code":500,
	"msg":"出现错误"
}
~~~~

#### 代码实现

工具类方法修改

WebUtils

~~~~java
    public static void setDownLoadHeader(String filename, HttpServletResponse response) throws UnsupportedEncodingException {
        response.setContentType("application/vnd.openxmlformats-officedocument.spreadsheetml.sheet");
        response.setCharacterEncoding("utf-8");
        String fname= URLEncoder.encode(filename,"UTF-8").replaceAll("\\+", "%20");
        response.setHeader("Content-disposition","attachment; filename="+fname);
    }
~~~~

CategoryController

~~~~java
    @GetMapping("/export")
    public void export(HttpServletResponse response){
        try {
            //设置下载文件的请求头
            WebUtils.setDownLoadHeader("分类.xlsx",response);
            //获取需要导出的数据
            List<Category> categoryVos = categoryService.list();

            List<ExcelCategoryVo> excelCategoryVos = BeanCopyUtils.copyBeanList(categoryVos, ExcelCategoryVo.class);
            //把数据写入到Excel中
            EasyExcel.write(response.getOutputStream(), ExcelCategoryVo.class).autoCloseStream(Boolean.FALSE).sheet("分类导出")
                    .doWrite(excelCategoryVos);

        } catch (Exception e) {
            //如果出现异常也要响应json
            ResponseResult result = ResponseResult.errorResult(AppHttpCodeEnum.SYSTEM_ERROR);
            WebUtils.renderString(response, JSON.toJSONString(result));
        }
    }
~~~~

ExcelCategoryVo

~~~~java
@Data
@NoArgsConstructor
@AllArgsConstructor
public class ExcelCategoryVo {
    @ExcelProperty("分类名")
    private String name;
    //描述
    @ExcelProperty("描述")
    private String description;

    //状态0:正常,1禁用
    @ExcelProperty("状态0:正常,1禁用")
    private String status;
}
~~~~

### 权限控制

#### 需求

需要对导出分类的接口做权限控制。

sg   eyJhbGciOiJIUzI1NiJ9.eyJqdGkiOiJkZGJkNjM5MWJiZTA0NmMzOTc4NDg1ZTcxNWQ3YjQ0MSIsInN1YiI6IjEiLCJpc3MiOiJzZyIsImlhdCI6MTY2MjI0NDE4NywiZXhwIjoxNjYyMzMwNTg3fQ.z4JGwFN3lWyVbOCbhikCe-O4D6SvCQFEE5eQY3jDJkw

sangeng

eyJhbGciOiJIUzI1NiJ9.eyJqdGkiOiI0Y2I1ZjhmMTc0Mjk0NzM0YjI4Y2M1NTQzYjQ2Yjc1YyIsInN1YiI6IjYiLCJpc3MiOiJzZyIsImlhdCI6MTY2MjI0NDQzMywiZXhwIjoxNjYyMzMwODMzfQ.yEkbyGYXBp5ndnyq-3acdgpvqx2mnI8B9fK9f3Y6Jco

#### 代码实现

SecurityConfig

~~~~java
@EnableGlobalMethodSecurity(prePostEnabled = true)
~~~~

UserDetailsServiceImpl

~~~~java
@Service
public class UserDetailsServiceImpl implements UserDetailsService {

    @Autowired
    private UserMapper userMapper;

    @Autowired
    private MenuMapper menuMapper;

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        //根据用户名查询用户信息
        LambdaQueryWrapper<User> queryWrapper = new LambdaQueryWrapper<>();
        queryWrapper.eq(User::getUserName,username);
        User user = userMapper.selectOne(queryWrapper);
        //判断是否查到用户  如果没查到抛出异常
        if(Objects.isNull(user)){
            throw new RuntimeException("用户不存在");
        }
        //返回用户信息
        if(user.getType().equals(SystemConstants.ADMAIN)){
            List<String> list = menuMapper.selectPermsByUserId(user.getId());
            return new LoginUser(user,list);
        }
        return new LoginUser(user,null);
    }
}
~~~~

LoginUser

增加属性

~~~~java
private List<String> permissions;
~~~~

PermissionService

hasPermisson

~~~~java

@Service("ps")
public class PermissionService {

    /**
     * 判断当前用户是否具有permission
     * @param permission 要判断的权限
     * @return
     */
    public boolean hasPermission(String permission){
        //如果是超级管理员  直接返回true
        if(SecurityUtils.isAdmin()){
            return true;
        }
        //否则  获取当前登录用户所具有的权限列表 如何判断是否存在permission
        List<String> permissions = SecurityUtils.getLoginUser().getPermissions();
        return permissions.contains(permission);
    }
}
~~~~

CategoryController

~~~~java

    @PreAuthorize("@ps.hasPermission('content:category:export')")
    @GetMapping("/export")
    public void export(HttpServletResponse response){
        try {
            //设置下载文件的请求头
            WebUtils.setDownLoadHeader("分类.xlsx",response);
            //获取需要导出的数据
            List<Category> categoryVos = categoryService.list();

            List<ExcelCategoryVo> excelCategoryVos = BeanCopyUtils.copyBeanList(categoryVos, ExcelCategoryVo.class);
            //把数据写入到Excel中
            EasyExcel.write(response.getOutputStream(), ExcelCategoryVo.class).autoCloseStream(Boolean.FALSE).sheet("分类导出")
                    .doWrite(excelCategoryVos);

        } catch (Exception e) {
            //如果出现异常也要响应json
            ResponseResult result = ResponseResult.errorResult(AppHttpCodeEnum.SYSTEM_ERROR);
            WebUtils.renderString(response, JSON.toJSONString(result));
        }
    }
~~~~

### 文章列表

#### 需求

为了对文章进行管理，需要提供文章列表

在后台需要分页查询文章功能，要求能根据标题和摘要**模糊查询**

注意：不能把删除了的文章查询出来

#### 接口设计

| 请求方式 | 请求路径              | 是否需求token头 |
| -------- | --------------------- | --------------- |
| Get      | /content/article/list | 是              |

Query格式请求参数：

pageNum: 页码

pageSize: 每页条数

title：文章标题

summary：文章摘要

响应格式：

~~~~json
{
	"code":200,
	"data":{
		"rows":[
			{
				"categoryId":"1",
				"content":"嘻嘻嘻嘻嘻嘻",
				"createTime":"2022-01-24 07:20:11",
				"id":"1",
				"isComment":"0",
				"isTop":"1",
				"status":"0",
				"summary":"SpringSecurity框架教程-Spring Security+JWT实现项目级前端分离认证授权",
				"thumbnail":"https://sg-blog-oss.oss-cn-beijing.aliyuncs.com/2022/01/31/948597e164614902ab1662ba8452e106.png",
				"title":"SpringSecurity从入门到精通",
				"viewCount":"161"
			}
		],
		"total":"1"
	},
	"msg":"操作成功"
}
~~~~

#### 代码实现

ArticleController

```java
@GetMapping("/list")
    public ResponseResult list(Integer pageNum,Integer pageSize,String title,String summary){
        return articleService.articleList(pageNum,pageSize,title,summary);
    }
```

ArticleServiceImpl

```java
 @Override
    public ResponseResult articleList(Integer pageNum, Integer pageSize, String title, String summary) {
        //查询条件
        LambdaQueryWrapper<Article> lambdaQueryWrapper = new LambdaQueryWrapper<>();
        // 模糊匹配title和summary
        //第一个参数：一个bool表达式，要求前端传来了categoryId并且大于0。如果这个参数为true，就会把对第二，三个参数的判断加到sql语句中
        lambdaQueryWrapper.like(Objects.nonNull(title),Article::getTitle,title);
        lambdaQueryWrapper.like(Objects.nonNull(summary),Article::getSummary,summary);
        // 状态是正式发布的
        lambdaQueryWrapper.eq(Article::getStatus,SystemConstants.ARTICLE_STATUS_NORMAL);
        // 按isTop进行降序
        lambdaQueryWrapper.orderByDesc(Article::getIsTop);
        //分页查询
        Page<Article> page = new Page<>(pageNum,pageSize);
        page(page,lambdaQueryWrapper);
        //封装查询结果
        List<AdminArticleListVo> articleListVos = BeanCopyUtils.copyBeanList(page.getRecords(), AdminArticleListVo.class);
        PageVo pageVo = new PageVo(articleListVos,page.getTotal());
        return ResponseResult.okResult(pageVo);
    }
```

创建AdminArticleListVo

```java
@Data
@NoArgsConstructor
@AllArgsConstructor
public class AdminArticleListVo {

    private Long id;
    //标题
    private String title;
    //文章摘要
    private String summary;
    //所属分类名id
    private Long categoryId;
    //所属分类名
    private String categoryName;
    //缩略图
    private String thumbnail;
    //文章内容
    private String content;
    //访问量
    private Long viewCount;

    private Date createTime;
   
    private String isTop;
    
    private String status;
    
    private String isComment;
}
```

### 修改文章

#### 需求

点击文章列表中的修改按钮可以跳转到写博文页面。回显示该文章的具体信息。

用户可以在该页面修改文章信息。点击更新按钮后修改文章。

#### 分析

这个功能的实现首先需要能够根据文章id查询文章的详细信息这样才能实现文章的回显。

如何需要提供更新文章的接口。

#### 接口设计

##### 查询文章详情接口

| 请求方式 | 请求路径             | 是否需求token头 |
| -------- | -------------------- | --------------- |
| Get      | content/article/{id} | 是              |

Path格式请求参数：

id: 文章id

响应格式：

~~~~json
{
	"code":200,
	"data":{
		"categoryId":"1",
		"content":"xxxxxxx",
		"createBy":"1",
		"createTime":"2022-08-28 15:15:46",
		"delFlag":0,
		"id":"10",
		"isComment":"0",
		"isTop":"1",
		"status":"0",
		"summary":"啊实打实",
		"tags":[
			"1",
			"4",
			"5"
		],
		"thumbnail":"https://sg-blog-oss.oss-cn-beijing.aliyuncs.com/2022/08/28/7659aac2b74247fe8ebd9e054b916dbf.png",
		"title":"委屈饿驱蚊器",
		"updateBy":"1",
		"updateTime":"2022-08-28 15:15:46",
		"viewCount":"0"
	},
	"msg":"操作成功"
}
~~~~

##### 更新文章接口

| 请求方式 | 请求路径        | 是否需求token头 |
| -------- | --------------- | --------------- |
| PUT      | content/article | 是              |

请求体参数格式：

~~~~json
{
    "categoryId":"1",
    "content":"![Snipaste_20220228_224837.png](https://sg-blog-oss.oss-cn-beijing.aliyuncs.com/2022/08/28/f3938a0368c540ee909ba7f7079a829a.png)\n\n# 十大\n## 时代的",
    "createBy":"1",
    "createTime":"2022-08-28 15:15:46",
    "delFlag":0,
    "id":"10",
    "isComment":"0",
    "isTop":"1",
    "status":"0",
    "summary":"啊实打实2",
    "tags":[
        "1",
        "4",
        "5"
    ],
    "thumbnail":"https://sg-blog-oss.oss-cn-beijing.aliyuncs.com/2022/08/28/7659aac2b74247fe8ebd9e054b916dbf.png",
    "title":"委屈饿驱蚊器",
    "updateBy":"1",
    "updateTime":"2022-08-28 15:15:46",
    "viewCount":"0"
}
~~~~

响应格式：

~~~~json
{
	"code":200,
	"msg":"操作成功"
}
~~~~

#### 代码实现

##### 查询文章详情

ArticleController

```java
@GetMapping("/{id}")
    public ResponseResult getArticleDetail(@PathVariable("id") Long id){
        return articleService.getArticleAllDetail(id);
    }
```

Article添加字段

```java
@TableField(exist = false)
    private List<Long> tags;
```

ArticleServiceImpl

```java
@Override
    public ResponseResult getArticleAllDetail(Long id) {
        //根据id查询文章
        Article article = getById(id);
        //从redis中获取viewCount
        Integer viewCount = redisCache.getCacheMapValue("article:viewCount", id.toString());
        article.setViewCount(viewCount.longValue());
        //从article_tag表里把这个文章的所有标签找到
        LambdaQueryWrapper<ArticleTag> queryWrapper=new LambdaQueryWrapper<>();
        queryWrapper.select(ArticleTag::getTagId);
        queryWrapper.eq(ArticleTag::getArticleId,id);
        List<Long> tags =articleTagService.selectTagsList(queryWrapper);
        article.setTags(tags);
        //封装响应返回
        return ResponseResult.okResult(article);
    }
```

ArticleTagServiceImpl

```java
@Override
    public List<Long> selectTagsList(LambdaQueryWrapper<ArticleTag> queryWrapper) {
        List<ArticleTag> list=list(queryWrapper);
        List<Long> tags=new ArrayList<>();
        for (ArticleTag articleTag:list) {
            tags.add(articleTag.getTagId());
        }
        return tags;
    }
```

##### 更新文章（还没想好怎么改tags）



### 删除文章

#### 需求

点击文章后面的删除按钮可以删除该文章

注意：是逻辑删除不是物理删除

#### 接口设计

| 请求方式 | 请求路径             | 是否需求token头 |
| -------- | -------------------- | --------------- |
| DELETE   | content/article/{id} | 是              |

Path请求参数：

id：要删除的文章id

响应格式：

~~~~json
{
	"code":200,
	"msg":"操作成功"
}
~~~~

#### 代码实现

ArticleController

不仅要逻辑删除文章，还要把article_tag表和xhr_comment表中于这篇文章相关的记录删掉(这里应该可以不做地这么绝，只是逻辑删除文章应该更安全，毕竟误删了也可以找回以前的数据)

```java
 @DeleteMapping("/{id}")
    public ResponseResult deleteArticle(@PathVariable("id") Long id){
        return articleService.deleteById(id);
    }
```

ArticleServiceImpl

```java
@Override
    public ResponseResult deleteById(Long id) {
        //删除article_tag表里所有和该文章关联的记录
        LambdaQueryWrapper<ArticleTag> queryWrapper1=new LambdaQueryWrapper<>();
        queryWrapper1.eq(ArticleTag::getArticleId,id);
        articleTagService.remove(queryWrapper1);
        //删除xhr_comment表中所有和该文章关联的记录
        LambdaQueryWrapper<Comment> queryWrapper2=new LambdaQueryWrapper<>();
        queryWrapper2.eq(Comment::getArticleId,id);
        commentService.remove(queryWrapper2);
        removeById(id);
        //在文章表里逻辑删除
        removeById(id);
        return ResponseResult.okResult();
    }
```

### 菜单列表

#### 需求

需要展示菜单列表，不需要分页。

可以针对菜单名进行模糊查询

也可以针对菜单的状态进行查询。

菜单要按照父菜单id和orderNum进行排序

#### 接口设计

| 请求方式 | 请求路径         | 是否需求token头 |
| -------- | ---------------- | --------------- |
| GET      | system/menu/list | 是              |

Query请求参数：

status  : 状态

menuName： 菜单名

响应格式：

~~~~json
{
	"code":200,
	"data":[
		{
			"component":"content/article/write/index",
			"icon":"build",
			"id":"2023",
			"isFrame":1,
			"menuName":"写博文",
			"menuType":"C",
			"orderNum":0,
			"parentId":"0",
			"path":"write",
			"perms":"content:article:writer",
			"remark":"",
			"status":"0",
			"visible":"0"
		},
		{
			"icon":"system",
			"id":"1",
			"isFrame":1,
			"menuName":"系统管理",
			"menuType":"M",
			"orderNum":1,
			"parentId":"0",
			"path":"system",
			"perms":"",
			"remark":"系统管理目录",
			"status":"0",
			"visible":"0"
		},
		{
			"icon":"table",
			"id":"2017",
			"isFrame":1,
			"menuName":"内容管理",
			"menuType":"M",
			"orderNum":4,
			"parentId":"0",
			"path":"content",
			"remark":"",
			"status":"0",
			"visible":"0"
		},
		.....
	],
	"msg":"操作成功"
}
~~~~

#### 代码实现

MenuController

```java
@RestController
@RequestMapping("/system/menu")
public class MenuController {
    @Resource
    MenuService menuService;
    @GetMapping("/list")
    public ResponseResult list(String status,String menuName){
        return menuService.list(status,menuName);
    }
}
```

MenuServiceImpl

```java
@Override
    public ResponseResult list(String status, String menuName) {
        //模糊匹配以及排序规则
        LambdaQueryWrapper<Menu> queryWrapper=new LambdaQueryWrapper<>();
        queryWrapper.like(Objects.nonNull(status),Menu::getStatus,status);
        queryWrapper.like(Objects.nonNull(menuName),Menu::getMenuName,menuName);
        queryWrapper.orderByDesc(Menu::getId,Menu::getOrderNum);
        List<Menu> list=list(queryWrapper);
        //封装成menuVo返回
        List<MenuVo> menuVos= BeanCopyUtils.copyBeanList(list, MenuVo.class);
        return ResponseResult.okResult(menuVos);
    }
```

MenuVo

```java
@Data
@AllArgsConstructor
@NoArgsConstructor
@Accessors(chain = true)
public class MenuVo {
    //菜单ID
    private Long id;
    //菜单名称
    private String menuName;
    //父菜单ID
    private Long parentId;
    //显示顺序
    private Integer orderNum;
    //路由地址
    private String path;
    //组件路径
    private String component;
    //是否为外链（0是 1否）
    private Integer isFrame;
    //菜单类型（M目录 C菜单 F按钮）
    private String menuType;
    //菜单状态（0显示 1隐藏）
    private String visible;
    //菜单状态（0正常 1停用）
    private String status;
    //菜单图标
    private String icon;
    //创建时间
    private Date createTime;
    //备注
    private String remark;
    //权限标识
    private String perms;
}
```

### 新增菜单

#### 需求

可以新增菜单

#### 接口设计

| 请求方式 | 请求路径        | 是否需求token头 |
| -------- | --------------- | --------------- |
| POST     | content/article | 是              |

请求体参数：

Menu类对应的json格式

响应格式：

~~~~json
{
	"code":200,
	"msg":"操作成功"
}
~~~~

#### 代码实现（好像还没考虑role_menu）

MenuController

```java
@PostMapping()
    public ResponseResult addMenu(@RequestBody Menu menu){
        return menuService.addMenu(menu);
    }
```

MenuServiceImpl

```java
@Override
    public ResponseResult addMenu(Menu menu) {
        save(menu);
        return ResponseResult.okResult();
    }
```

Menu字段自动填充

```java
@TableField(fill = FieldFill.INSERT)
    private Long createBy;
    //创建时间
    @TableField(fill = FieldFill.INSERT)
    private Date createTime;
    //更新者
    @TableField(fill = FieldFill.INSERT_UPDATE)
    private Long updateBy;
    //更新时间
    @TableField(fill = FieldFill.INSERT_UPDATE)
    private Date updateTime;
```
### 修改菜单

#### 需求

点击“修改”按钮可以回显菜单信息，点击“确定”可以修改菜单

注意：修改的时候不能把父菜单设置为当前菜单(自己是自己的父，死循环)，如果设置了需要给出相应的提示。并且修改失败。

#### 接口设计

##### 根据id查询菜单数据

| 请求方式 | 请求路径         | 是否需求token头 |
| -------- | ---------------- | --------------- |
| Get      | system/menu/{id} | 是              |

Path格式请求参数：

id: 菜单id

响应格式：

~~~~json
{
	"code":200,
	"data":{
		"icon":"table",
		"id":"2017",
		"menuName":"内容管理",
		"menuType":"M",
		"orderNum":"4",
		"parentId":"0",
		"path":"content",
		"remark":"",
		"status":"0",
		"visible":"0"
	},
	"msg":"操作成功"
}
~~~~

##### 更新菜单

| 请求方式 | 请求路径    | 是否需求token头 |
| -------- | ----------- | --------------- |
| PUT      | system/menu | 是              |

请求体参数：

Menu类对应的json格式

响应格式：

~~~~json
{
	"code":200,
	"msg":"操作成功"
}
~~~~

如果把父菜单设置为当前菜单:

~~~~java
{
	"code":500,
	"msg":"修改菜单'写博文'失败，上级菜单不能选择自己"
}
~~~~

#### 代码实现

##### 回显菜单数据

MenuController

```java
@GetMapping("/{id}")
    public ResponseResult getMenuInfo(@PathVariable("id") Long id){
        return menuService.getMenuInfo(id);
    }
```

MenuServiceImpl

```java
@Override
    public ResponseResult getMenuInfo(Long id) {
        LambdaQueryWrapper<Menu> queryWrapper=new LambdaQueryWrapper<>();
        queryWrapper.eq(Menu::getId,id);
        Menu menu=getOne(queryWrapper);
        MenuInfoVo menuInfoVo=BeanCopyUtils.copyBean(menu,MenuInfoVo.class);
        return ResponseResult.okResult(menuInfoVo);
    }
```

创建MenuInfoVo

```java
@Data
@AllArgsConstructor
@NoArgsConstructor
@Accessors(chain = true)
public class MenuInfoVo {
    //菜单ID
    private Long id;
    //菜单名称
    private String menuName;
    //父菜单ID
    private Long parentId;
    //显示顺序
    private Integer orderNum;
    //路由地址
    private String path;
    //菜单类型（M目录 C菜单 F按钮）
    private String menuType;
    //菜单状态（0显示 1隐藏）
    private String visible;
    //菜单状态（0正常 1停用）
    private String status;
    //菜单图标
    private String icon;
    //备注
    private String remark;
}
```


##### 更新菜单(没考虑role_menu)

MenuController

```java
 @PutMapping()
    public ResponseResult updateMenu(@RequestBody Menu menu){
        return menuService.updateMenu(menu);
    }
```

MenuServiceImpl

```java
@Override
    public ResponseResult updateMenu(Menu menu) {
        if (menu.getParentId().equals(menu.getId())){
            return ResponseResult.errorResult(AppHttpCodeEnum.SYSTEM_ERROR,"修改菜单'写博文'失败，上级菜单不能选择自己");
        }
        updateById(menu);
        return ResponseResult.okResult();
    }
```


### 删除菜单

#### 需求

能够删除菜单，但是如果要删除的菜单有子菜单则提示：存在子菜单不允许删除 并且删除失败。

#### 接口设计

| 请求方式 | 请求路径                 | 是否需求token头 |
| -------- | ------------------------ | --------------- |
| DELETE   | content/article/{menuId} | 是              |

Path参数：

menuId：要删除菜单的id

响应格式：

~~~~json
{
	"code":200,
	"msg":"操作成功"
}
~~~~

如果要删除的菜单有子菜单则

~~~~java
{
	"code":500,
	"msg":"存在子菜单不允许删除"
}
~~~~

#### 代码实现(没考虑role_menu)

MenuController

```java
 @DeleteMapping("/{menuId}")
    public ResponseResult deleteMenu(@PathVariable("menuId") Long menuId){
        return menuService.deleteMenu(menuId);
    }
```

MenuServiceImpl

```java
 @Override
    public ResponseResult deleteMenu(Long menuId) {
        //查询有无以待删菜单为父菜单的菜单，如果有，则不能删
        LambdaQueryWrapper<Menu> queryWrapper=new LambdaQueryWrapper<>();
        queryWrapper.eq(Menu::getParentId,menuId);
        if(list(queryWrapper).isEmpty()){
            removeById(menuId);
            return ResponseResult.okResult();
        }
        return ResponseResult.errorResult(AppHttpCodeEnum.SYSTEM_ERROR,"存在子菜单不允许删除");
    }
```

### 角色列表

#### 需求

需要有角色列表分页查询的功能。

要求能够针对角色名称进行模糊查询。

要求能够针对状态进行查询。

要求按照role_sort进行升序排列。

#### 接口设计

| 请求方式 | 请求路径         | 是否需求token头 |
| -------- | ---------------- | --------------- |
| GET      | system/role/list | 是              |

Query格式请求参数：

pageNum: 页码

pageSize: 每页条数

roleName：角色名称

status：状态

响应格式：

~~~~json
{
	"code":200,
	"data":{
		"rows":[
			{
				"id":"12",
				"roleKey":"link",
				"roleName":"友链审核员",
				"roleSort":"1",
				"status":"0"
			}
		],
		"total":"1"
	},
	"msg":"操作成功"
}
~~~~

#### 代码实现

RoleController

```java
@RestController
@RequestMapping("/system/role")
public class RoleController {
    @Resource
    RoleService roleService;
    @GetMapping("/list")
    public ResponseResult list(Integer pageNum,Integer pageSize,String roleName,String status){
        return roleService.roleList(pageNum,pageSize,roleName,status);
    }
}
```

RoleServiceImpl

```java
@Override
    public ResponseResult roleList(Integer pageNum, Integer pageSize, String roleName, String status) {
        //查询条件
        LambdaQueryWrapper<Role> lambdaQueryWrapper = new LambdaQueryWrapper<>();
        // 模糊匹配
        //第一个参数：一个bool表达式，要求前端传来了categoryId并且大于0。如果这个参数为true，就会把对第二，三个参数的判断加到sql语句中
        lambdaQueryWrapper.like(Objects.nonNull(roleName),Role::getRoleName,roleName);
        lambdaQueryWrapper.like(Objects.nonNull(status),Role::getStatus,status);
        // 按roleSort进行升序
        lambdaQueryWrapper.orderByAsc(Role::getRoleSort);
        //分页查询
        Page<Role> page = new Page<>(pageNum,pageSize);
        page(page,lambdaQueryWrapper);
        //封装查询结果
        List<RoleVo> roleVos = BeanCopyUtils.copyBeanList(page.getRecords(), RoleVo.class);
        PageVo pageVo = new PageVo(roleVos,page.getTotal());
        return ResponseResult.okResult(pageVo);
    }
```

RoleVo

```java
@Data
@NoArgsConstructor
@AllArgsConstructor
public class RoleVo {
    //角色ID@TableId
    private Long id;
    //角色名称
    private String roleName;
    //角色权限字符串
    private String roleKey;
    //显示顺序
    private Integer roleSort;
    //角色状态（0正常 1停用）
    private String status;
}
```

### 改变角色状态

#### 需求

要求能够修改角色的停启用状态

#### 接口设计

| 请求方式 | 请求路径                 | 是否需求token头 |
| -------- | ------------------------ | --------------- |
| PUT      | system/role/changeStatus | 是              |

请求体：

~~~~json
{"id":"11","status":"1"}
~~~~

响应格式：

~~~~json
{
	"code":200,
	"msg":"操作成功"
}
~~~~

#### 代码实现(自动填充不行)

RoleController

```java
 @PutMapping("/changeStatus")
    public ResponseResult changeStatus(@RequestBody Role role){
        return roleService.changeStatus(role);
    }
```

RoleServiceImpl

```java
@Override
    public ResponseResult changeStatus(Role role) {
        UpdateWrapper<Role> updateWrapper=new UpdateWrapper<>();
        updateWrapper.eq("id",role.getId());
        updateWrapper.set("status",role.getStatus());
        if (update(updateWrapper)){
            return ResponseResult.okResult();
        }
        return ResponseResult.errorResult(AppHttpCodeEnum.SYSTEM_ERROR,"未知错误，修改失败");
    }
```

Role自动填充（没用？？？）

```java
    @TableField(fill = FieldFill.INSERT)
    private Long createBy;
    @TableField(fill = FieldFill.INSERT)
    private Date createTime;
    @TableField(fill = FieldFill.INSERT_UPDATE)
    private Long updateBy;
    @TableField(fill = FieldFill.INSERT_UPDATE)
    private Date updateTime;
```

### 新增角色！！

#### 需求

需要提供新增角色的功能。新增角色时能够直接设置角色所关联的菜单权限。

#### 接口设计

##### 获取菜单树接口

| 请求方式 | 请求路径                | 是否需求token头 |
| -------- | ----------------------- | --------------- |
| GET      | /system/menu/treeselect | 是              |

无需请求参数

响应格式：

~~~~json
{
	"code":200,
	"data":[
		{
			"children":[],
			"id":"2023",
			"label":"写博文",
			"parentId":"0"
		},
		{
			"children":[
				{
					"children":[
						{
							"children":[],
							"id":"1001",
							"label":"用户查询",
							"parentId":"100"
						},
						{
							"children":[],
							"id":"1002",
							"label":"用户新增",
							"parentId":"100"
						},
						.....
					],
					"id":"100",
					"label":"用户管理",
					"parentId":"1"
				},
				{
					"children":[
						.....
					],
					"id":"101",
					"label":"角色管理",
					"parentId":"1"
				},
				.....
			],
			"id":"1",
			"label":"系统管理",
			"parentId":"0"
		},
		.....
	],
	"msg":"操作成功"
}
~~~~

##### 新增角色接口

| 请求方式 | 请求路径    | 是否需求token头 |
| -------- | ----------- | --------------- |
| POST     | system/role | 是              |

请求体：

~~~~json
{
    "roleName":"测试新增角色",
    "roleKey":"wds",
    "roleSort":0,
    "status":"0",
    "menuIds":[
        "1",
        "100"
    ],
    "remark":"我是角色备注"
}
~~~~

响应格式：

~~~~json
{
	"code":200,
	"msg":"操作成功"
}
~~~~

#### 代码实现

##### 获取菜单树

注：因为前端想要的是label，我又不会改前端，那就只能先bean拷贝得到menuName，然后用set方法给到label

MenuController

```java
 @GetMapping("/treeselect")
    public ResponseResult getMenuTree(){return menuService.getMenuTree(0L);}
```

MenuTreeVo

```java
@Data
@AllArgsConstructor
@NoArgsConstructor
@Accessors(chain = true)
public class MenuTreeVo {
    private Long id;
    private String label;
    //因为前端想要的是label，我又不会改前端，那就只能先bean拷贝得到menuName，然后用set方法给到label
    private String menuName;
    private Long parentId;
    private List<MenuTreeVo> children;
}
```

MenuServiceImpl

就是抄之前getRouter接口，只是操作的是MenuTreeVo类型

```java
@Override
    public ResponseResult getMenuTree(Long userId) {
        MenuMapper menuMapper = getBaseMapper();
        List<Menu> menus = null;
        //判断是否是管理员
        if(SecurityUtils.isAdmin()){
            //如果是 获取所有符合要求的Menu
            menus = menuMapper.selectAllRouterMenu();
        }else{
            //否则  获取当前用户所具有的Menu
            menus = menuMapper.selectRouterMenuTreeByUserId(userId);
        }

        //构建tree,先把第一层bean拷贝为vo
        //先找出第一层的菜单  然后去找他们的子菜单设置到children属性中
        List<MenuTreeVo> menuTreeVos = BeanCopyUtils.copyBeanList(menus, MenuTreeVo.class);
        //因为前端想要的是label，我又不会改前端，那就只能先bean拷贝得到menuName，然后用set方法给到label
        for (MenuTreeVo menuTreeVo :menuTreeVos) {
            menuTreeVo.setLabel(menuTreeVo.getMenuName());
        }
        menuTreeVos = builderMenuTreeVos(menuTreeVos,0L);

        return ResponseResult.okResult(menuTreeVos);
    }

    private List<MenuTreeVo> builderMenuTreeVos(List<MenuTreeVo> menuTreeVos, long parentId) {
        List<MenuTreeVo> menuTree = menuTreeVos.stream()
                .filter(menuTreeVo -> menuTreeVo.getParentId().equals(parentId))
                .map(menuTreeVo -> menuTreeVo.setChildren(getChildren(menuTreeVo,menuTreeVos)))
                .collect(Collectors.toList());
        return menuTree;
    }

    private List<MenuTreeVo> getChildren(MenuTreeVo menuTreeVo, List<MenuTreeVo> menuTreeVos) {
        List<MenuTreeVo> childrenList = menuTreeVos.stream()
                .filter(m -> m.getParentId().equals(menuTreeVo.getId()))
                .map(m->m.setChildren(getChildren(m,menuTreeVos)))
                .collect(Collectors.toList());
        return childrenList;
    }
```

##### 新增角色

① sys_role_menu表生成对应实体类，mapper类，service类，serviceimpl类

② 为了方便接收请求传过来的参数，创建AddRoleDto类

```java
@Data
@AllArgsConstructor
@NoArgsConstructor
public class AddRoleDto {
    //角色名称
    private String roleName;
    //角色权限字符串
    private String roleKey;
    //显示顺序
    private Integer roleSort;
    //角色状态（0正常 1停用）
    private String status;
    //备注
    private String remark;
    private List<Long> menuIds;
}
```

③ controller层

```java
@PostMapping()
    public ResponseResult addRole(@RequestBody AddRoleDto addRoleDto){
        return roleService.addRole(addRoleDto);
    }
```

④ RoleServiceImpl

```java
 @Override
    public ResponseResult addRole(AddRoleDto roleDto) {
        //将role添加到sys_role数据库
        Role role = BeanCopyUtils.copyBean(roleDto, Role.class);
        save(role);
        //将role_id和menu_id成对添加到sys_role_menu数据库
        List<Long> menuIds = roleDto.getMenuIds();
        for (Long menu_id:menuIds) {
            roleMenuService.save(new RoleMenu(role.getId(),menu_id));
        }
        return ResponseResult.okResult();
    }
```




### 修改角色

#### 需求

需要提供修改角色的功能。修改角色时可以修改角色所关联的菜单权限

#### 接口设计

##### 角色信息回显接口

| 请求方式 | 请求路径         | 是否需求token头 |
| -------- | ---------------- | --------------- |
| Get      | system/role/{id} | 是              |

Path格式请求参数：

id: 角色id

响应格式：

~~~~json
{
	"code":200,
	"data":{
		"id":"11",
		"remark":"嘎嘎嘎",
		"roleKey":"aggag",
		"roleName":"嘎嘎嘎",
		"roleSort":"5",
		"status":"0"
	},
	"msg":"操作成功"
}
~~~~

##### 加载对应角色菜单列表树接口

| 请求方式 | 请求路径                             | 是否需求token头 |
| -------- | ------------------------------------ | --------------- |
| Get      | /system/menu/roleMenuTreeselect/{id} | 是              |

Path格式请求参数：

id: 角色id

响应格式：

字段介绍

​	menus：菜单树。

​	checkedKeys：角色所关联的菜单权限id列表。

~~~~json
{
	"code":200,
	"data":{
		"menus":[
			{
				"children":[],
				"id":"2023",
				"label":"写博文",
				"parentId":"0"
			},
			{
				"children":[
					{
						"children":[
							{
								"children":[],
								"id":"1001",
								"label":"用户查询",
								"parentId":"100"
							},
							{
								"children":[],
								"id":"1002",
								"label":"用户新增",
								"parentId":"100"
							},
							{
								"children":[],
								"id":"1003",
								"label":"用户修改",
								"parentId":"100"
							},
							{
								"children":[],
								"id":"1004",
								"label":"用户删除",
								"parentId":"100"
							},
							{
								"children":[],
								"id":"1005",
								"label":"用户导出",
								"parentId":"100"
							},
							{
								"children":[],
								"id":"1006",
								"label":"用户导入",
								"parentId":"100"
							},
							{
								"children":[],
								"id":"1007",
								"label":"重置密码",
								"parentId":"100"
							}
						],
						"id":"100",
						"label":"用户管理",
						"parentId":"1"
					},
					{
						"children":[
							{
								"children":[],
								"id":"1008",
								"label":"角色查询",
								"parentId":"101"
							},
							{
								"children":[],
								"id":"1009",
								"label":"角色新增",
								"parentId":"101"
							},
							{
								"children":[],
								"id":"1010",
								"label":"角色修改",
								"parentId":"101"
							},
							{
								"children":[],
								"id":"1011",
								"label":"角色删除",
								"parentId":"101"
							},
							{
								"children":[],
								"id":"1012",
								"label":"角色导出",
								"parentId":"101"
							}
						],
						"id":"101",
						"label":"角色管理",
						"parentId":"1"
					},
					{
						"children":[
							{
								"children":[],
								"id":"1013",
								"label":"菜单查询",
								"parentId":"102"
							},
							{
								"children":[],
								"id":"1014",
								"label":"菜单新增",
								"parentId":"102"
							},
							{
								"children":[],
								"id":"1015",
								"label":"菜单修改",
								"parentId":"102"
							},
							{
								"children":[],
								"id":"1016",
								"label":"菜单删除",
								"parentId":"102"
							}
						],
						"id":"102",
						"label":"菜单管理",
						"parentId":"1"
					}
				],
				"id":"1",
				"label":"系统管理",
				"parentId":"0"
			},
			{
				"children":[
					{
						"children":[],
						"id":"2019",
						"label":"文章管理",
						"parentId":"2017"
					},
					{
						"children":[
							{
								"children":[],
								"id":"2028",
								"label":"导出分类",
								"parentId":"2018"
							}
						],
						"id":"2018",
						"label":"分类管理",
						"parentId":"2017"
					},
					{
						"children":[
							{
								"children":[],
								"id":"2024",
								"label":"友链新增",
								"parentId":"2022"
							},
							{
								"children":[],
								"id":"2025",
								"label":"友链修改",
								"parentId":"2022"
							},
							{
								"children":[],
								"id":"2026",
								"label":"友链删除",
								"parentId":"2022"
							},
							{
								"children":[],
								"id":"2027",
								"label":"友链查询",
								"parentId":"2022"
							}
						],
						"id":"2022",
						"label":"友链管理",
						"parentId":"2017"
					},
					{
						"children":[],
						"id":"2021",
						"label":"标签管理",
						"parentId":"2017"
					}
				],
				"id":"2017",
				"label":"内容管理",
				"parentId":"0"
			}
		],
		"checkedKeys":[
			"1001"  
		]
	},
	"msg":"操作成功"
}
~~~~

##### 更新角色信息接口

| 请求方式 | 请求路径    | 是否需求token头 |
| -------- | ----------- | --------------- |
| PUT      | system/role | 是              |

请求体：

~~~~json
{
    "id":"13",
    "remark":"我是角色备注",
    "roleKey":"wds",
    "roleName":"测试新增角色",
    "roleSort":0,
    "status":"0",
    "menuIds":[
        "1",
        "100",
        "1001"
    ]
}
~~~~

响应格式：

~~~~json
{
	"code":200,
	"msg":"操作成功"
}
~~~~

### 删除角色

#### 需求

删除固定的某个角色（逻辑删除）

#### 接口设计

| 请求方式 | 请求路径         | 是否需求token头 |
| -------- | ---------------- | --------------- |
| DELETE   | system/role/{id} | 是              |

Path请求参数：

id：要删除的角色id

响应格式：

~~~~json
{
	"code":200,
	"msg":"操作成功"
}
~~~~

#### 代码实现

```java
@DeleteMapping("/{id}")
    public ResponseResult deleteById(@PathVariable("id") Long id){
        return ResponseResult.okResult(roleService.removeById(id));
    }
```

### 用户列表

#### 需求

需要用户分页列表接口。

可以根据用户名模糊搜索。

可以进行手机号的搜索。

可以进行状态的查询。

#### 接口设计

| 请求方式 | 请求路径         | 是否需求token头 |
| -------- | ---------------- | --------------- |
| GET      | system/user/list | 是              |

Query格式请求参数：

pageNum: 页码

pageSize: 每页条数

userName：用户名

phonenumber：手机号

status:状态

响应格式：

~~~~json
{
	"code":200,
	"data":{
		"rows":[
			{
				"avatar":"http://r7yxkqloa.bkt.clouddn.com/2022/03/05/75fd15587811443a9a9a771f24da458d.png",
				"createTime":"2022-01-05 17:01:56",
				"email":"23412332@qq.com",
				"id":"1",
				"nickName":"sg3334",
				"phonenumber":"18888888888",
				"sex":"1",
				"status":"0",
				"updateBy":"1",
				"updateTime":"2022-03-13 21:36:22",
				"userName":"sg"
			}
		],
		"total":"1"
	},
	"msg":"操作成功"
}
~~~~

#### 代码实现(电话号码的输入框有点问题)

UserController

```java
@RestController
@RequestMapping("/system/user")
public class UserController {
    @Resource
    UserService userService;
    @GetMapping("/list")
    public ResponseResult listUsers(Integer pageNum,Integer pageSize,String userName,String phonenumber,String status){
        return  userService.listUsers(pageNum,pageSize,userName,phonenumber,status);
    }
}
```

UserServiceImpl

```java
@Override
    public ResponseResult listUsers(Integer pageNum,Integer pageSize,String userName,String phonenumber,String status) {
        //查询条件
        LambdaQueryWrapper<User> lambdaQueryWrapper = new LambdaQueryWrapper<>();
        // 根据用户名模糊匹配
        //第一个参数：一个bool表达式，要求前端传来了categoryId并且大于0。如果这个参数为true，就会把对第二，三个参数的判断加到sql语句中
        lambdaQueryWrapper.like(Objects.nonNull(userName),User::getUserName,userName);
        //根据电话号码，状态进行搜索
        lambdaQueryWrapper.eq(Objects.nonNull(phonenumber),User::getPhonenumber,phonenumber);
        lambdaQueryWrapper.eq(Objects.nonNull(status),User::getStatus,status);
        //分页查询
        Page<User> page = new Page<>(pageNum,pageSize);
        page(page,lambdaQueryWrapper);
        //封装查询结果
        List<UserVo> userVos = BeanCopyUtils.copyBeanList(page.getRecords(), UserVo.class);
        PageVo pageVo = new PageVo(userVos,page.getTotal());
        return ResponseResult.okResult(pageVo);
    }
```

UserVo

```java
@Data
@AllArgsConstructor
@NoArgsConstructor
public class UserVo  {
    private Long id;
    //用户名
    private String userName;
    //昵称
    private String nickName;
    //账号状态（0正常 1停用）
    private String status;
    //邮箱
    private String email;
    //手机号
    private String phonenumber;
    //用户性别（0男，1女，2未知）
    private String sex;
    //头像
    private String avatar;
    //创建时间
    private Date createTime;
    //更新人
    private Long updateBy;
    //更新时间
    private Date updateTime;
}
```

### 新增用户

#### 需求

需要新增用户功能。新增用户时可以直接关联角色。

注意：新增用户时注意密码加密存储。

用户名不能为空，否则提示：必需填写用户名

用户名必须之前未存在，否则提示：用户名已存在

手机号必须之前未存在，否则提示：手机号已存在

邮箱必须之前未存在，否则提示：邮箱已存在

#### 接口设计

##### 查询角色列表接口

注意：查询的是所有状态正常的角色

| 请求方式 | 请求路径                 | 是否需求token头 |
| -------- | ------------------------ | --------------- |
| GET      | /system/role/listAllRole | 是              |

响应格式：

~~~~json
{
	"code":200,
	"data":[
		{
			"createBy":"0",
			"createTime":"2021-11-12 18:46:19",
			"delFlag":"0",
			"id":"1",
			"remark":"超级管理员",
			"roleKey":"admin",
			"roleName":"超级管理员",
			"roleSort":"1",
			"status":"0",
			"updateBy":"0"
		},
		{
			"createBy":"0",
			"createTime":"2021-11-12 18:46:19",
			"delFlag":"0",
			"id":"2",
			"remark":"普通角色",
			"roleKey":"common",
			"roleName":"普通角色",
			"roleSort":"2",
			"status":"0",
			"updateBy":"0",
			"updateTime":"2022-01-02 06:32:58"
		},
		{
			"createTime":"2022-01-06 22:07:40",
			"delFlag":"0",
			"id":"11",
			"remark":"嘎嘎嘎",
			"roleKey":"aggag",
			"roleName":"嘎嘎嘎",
			"roleSort":"5",
			"status":"0",
			"updateBy":"1",
			"updateTime":"2022-09-12 10:00:25"
		},
		{
			"createTime":"2022-01-16 14:49:30",
			"delFlag":"0",
			"id":"12",
			"roleKey":"link",
			"roleName":"友链审核员",
			"roleSort":"1",
			"status":"0",
			"updateTime":"2022-01-16 16:05:09"
		}
	],
	"msg":"操作成功"
}
~~~~

##### 新增用户

| 请求方式 | 请求路径    | 是否需求token头 |
| -------- | ----------- | --------------- |
| POST     | system/user | 是              |

请求体：

~~~~json
{
    "userName":"wqeree",
    "nickName":"测试新增用户",
    "password":"1234343",
    "phonenumber":"18889778907",
    "email":"233@sq.com",
    "sex":"0",
    "status":"0",
    "roleIds":[
        "2"
    ]
}
~~~~

响应格式：

~~~~json
{
	"code":200,
	"msg":"操作成功"
}
~~~~

#### 代码实现

##### 查询角色列表

```java
 @GetMapping("/listAllRole")
    public ResponseResult listAllRole(){
        return ResponseResult.okResult(roleService.list());
    }
```
##### 新增用户

① 根据sys_user_role表生成对应的实体类，mapper类，service类，serviceImpl类

② 创建AddUserDto类接收前端请求体中的参数

```java
@Data
@AllArgsConstructor
@NoArgsConstructor
public class AddUserDto {
    //用户名
    private String userName;
    //昵称
    private String nickName;
    //密码
    private String password;
    //账号状态（0正常 1停用）
    private String status;
    //邮箱
    private String email;
    //手机号
    private String phonenumber;
    //用户性别（0男，1女，2未知）
    private String sex;
    List<Long> roleIds;
}
```

③ controller层

```java
@PostMapping()
    public ResponseResult addUser(@RequestBody AddUserDto addUserDto){
        return userService.addUser(addUserDto);
    }
```

④ UserServiceImpl

```java
@Override
    public ResponseResult addUser(AddUserDto addUserDto) {
        //用户名不能为空，否则提示：必需填写用户名
        if (addUserDto.getUserName()==null)throw new SystemException(AppHttpCodeEnum.REQUIRE_USERNAME);
        //用户名必须之前未存在，否则提示：用户名已存在
        if(userNameExist(addUserDto.getUserName())) throw new SystemException(AppHttpCodeEnum.USERNAME_EXIST);
        //手机号必须之前未存在，否则提示：手机号已存在
        LambdaQueryWrapper<User> queryWrapper1 = new LambdaQueryWrapper<>();
        queryWrapper1.eq(User::getPhonenumber,addUserDto.getPhonenumber());
        if (count(queryWrapper1)>0)throw new SystemException(AppHttpCodeEnum.PHONENUMBER_EXIST);
        //邮箱必须之前未存在，否则提示：邮箱已存在
        LambdaQueryWrapper<User> queryWrapper2 = new LambdaQueryWrapper<>();
        queryWrapper2.eq(User::getEmail,addUserDto.getEmail());
        if (count(queryWrapper2)>0)throw new SystemException(AppHttpCodeEnum. EMAIL_EXIST);
        //符合要求，才能将用户添加到数据库
        User user = BeanCopyUtils.copyBean(addUserDto, User.class);
        user.setPassword(passwordEncoder.encode(user.getPassword()));//密码加密存储在数据库
        save(user);
        //然后还要把新用户的角色加入到用户角色关联表中
        for (Long roleId: addUserDto.getRoleIds()) {
            userRoleService.save(new UserRole(user.getId(),roleId));
        }
        return ResponseResult.okResult();
    }
```

### 删除用户

#### 需求

删除固定的某个用户（逻辑删除）

#### 接口设计

不能删除当前操作的用户

| 请求方式 | 请求路径          | 是否需求token头 |
| -------- | ----------------- | --------------- |
| DELETE   | /system/user/{id} | 是              |

Path请求参数：

id：要删除的用户id

响应格式：

~~~~json
{
	"code":200,
	"msg":"操作成功"
}
~~~~

#### 代码实现（没考虑user_role和menu_role）

```java
@DeleteMapping("/{id}")
    public ResponseResult deleteById(@PathVariable("id") Long id){
        return ResponseResult.okResult(roleService.removeById(id));
    }
```

### 修改用户

#### 需求

需要提供修改用户的功能。修改用户时可以修改用户所关联的角色。

#### 接口设计

##### 根据id查询用户信息回显接口

| 请求方式 | 请求路径          | 是否需求token头 |
| -------- | ----------------- | --------------- |
| Get      | /system/user/{id} | 是              |

Path格式请求参数：

id: 用户id

响应格式：

roleIds：用户所关联的角色id列表

roles：所有角色的列表

user：用户信息

~~~~json
{
	"code":200,
	"data":{
		"roleIds":[
			"11"
		],
		"roles":[
			{
				"createBy":"0",
				"createTime":"2021-11-12 18:46:19",
				"delFlag":"0",
				"id":"1",
				"remark":"超级管理员",
				"roleKey":"admin",
				"roleName":"超级管理员",
				"roleSort":"1",
				"status":"0",
				"updateBy":"0"
			},
			{
				"createBy":"0",
				"createTime":"2021-11-12 18:46:19",
				"delFlag":"0",
				"id":"2",
				"remark":"普通角色",
				"roleKey":"common",
				"roleName":"普通角色",
				"roleSort":"2",
				"status":"0",
				"updateBy":"0",
				"updateTime":"2022-01-02 06:32:58"
			},
			{
				"createTime":"2022-01-06 22:07:40",
				"delFlag":"0",
				"id":"11",
				"remark":"嘎嘎嘎",
				"roleKey":"aggag",
				"roleName":"嘎嘎嘎",
				"roleSort":"5",
				"status":"0",
				"updateBy":"1",
				"updateTime":"2022-09-11 20:34:49"
			},
			{
				"createTime":"2022-01-16 14:49:30",
				"delFlag":"0",
				"id":"12",
				"roleKey":"link",
				"roleName":"友链审核员",
				"roleSort":"1",
				"status":"0",
				"updateTime":"2022-01-16 16:05:09"
			}
		],
		"user":{
			"email":"weq@2132.com",
			"id":"14787164048663",
			"nickName":"sg777",
			"sex":"0",
			"status":"0",
			"userName":"sg777"
		}
	},
	"msg":"操作成功"
}
~~~~

##### 更新用户信息接口

| 请求方式 | 请求路径     | 是否需求token头 |
| -------- | ------------ | --------------- |
| PUT      | /system/user | 是              |

请求体：

~~~~json
{
    "email":"weq@2132.com",
    "id":"14787164048663",
    "nickName":"sg777",
    "sex":"1",
    "status":"0",
    "userName":"sg777",
    "roleIds":[
        "11"
    ]
}
~~~~

响应格式：

~~~~json
{
	"code":200,
	"msg":"操作成功"
}
~~~~

### 分页查询分类列表

#### 需求

需要分页查询分类列表。

能根据分类名称进行模糊查询。

能根据状态进行查询。

#### 接口设计

| 请求方式 | 请求路径              | 是否需求token头 |
| -------- | --------------------- | --------------- |
| GET      | content/category/list | 是              |

Query格式请求参数：

pageNum: 页码

pageSize: 每页条数

name：分类名

status: 状态

响应格式：

~~~~json
{
	"code":200,
	"data":{
		"rows":[
			{
				"description":"wsd",
				"id":"1",
				"name":"java",
				"status":"0"
			},
			{
				"description":"wsd",
				"id":"2",
				"name":"PHP",
				"status":"0"
			}
		],
		"total":"2"
	},
	"msg":"操作成功"
}
~~~~

#### 代码实现

CategoryController

```java
@GetMapping("/list")
    public ResponseResult listCategory(Integer pageNum,Integer pageSize, String name, String status){
        return categoryService.listCategory(pageNum,pageSize, name, status);
    }
```

CategoryServiceImpl

```java
@Override
    public ResponseResult listCategory(Integer pageNum, Integer pageSize, String name, String status) {
        //查询条件
        LambdaQueryWrapper<Category> lambdaQueryWrapper = new LambdaQueryWrapper<>();
        // 模糊匹配
        //第一个参数：一个bool表达式，要求前端传来了categoryId并且大于0。如果这个参数为true，就会把对第二，三个参数的判断加到sql语句中
        lambdaQueryWrapper.like(Objects.nonNull(name),Category::getName,name);
        //根据状态查询
        lambdaQueryWrapper.eq(Objects.nonNull(status),Category::getStatus,status);
        //分页查询
        Page<Category> page = new Page<>(pageNum,pageSize);
        page(page,lambdaQueryWrapper);
        //封装查询结果
        List<CategoryVo> categoryVos = BeanCopyUtils.copyBeanList(page.getRecords(), CategoryVo.class);
        PageVo pageVo = new PageVo(categoryVos,page.getTotal());
        return ResponseResult.okResult(pageVo);
    }
```

### 新增分类

#### 需求

需要新增分类功能

#### 接口设计

| 请求方式 | 请求路径          | 是否需求token头 |
| -------- | ----------------- | --------------- |
| POST     | /content/category | 是              |

请求体：

~~~~json
{
    "name":"威威",
    "description":"是的",
    "status":"0"
}
~~~~

响应格式：

~~~~json
{
	"code":200,
	"msg":"操作成功"
}
~~~~

#### 代码实现

CategoryController

```java
@PostMapping()
    public ResponseResult addCategory(@RequestBody Category category){
        return categoryService.addCategory(category);
    }
```

CategoryServiceImpl

```java
@Override
    public ResponseResult addCategory(Category category) {
        save(category);
        return ResponseResult.okResult();
    }
```

Category自动填充

### 修改分类

#### 需求

需要提供修改分类的功能

#### 接口设计

##### 根据id查询分类

| 请求方式 | 请求路径              | 是否需求token头 |
| -------- | --------------------- | --------------- |
| Get      | content/category/{id} | 是              |

Path格式请求参数：

id: 分类id

响应格式：

~~~~json
{
	"code":200,
	"data":{
		"description":"qwew",
		"id":"4",
		"name":"ww",
		"status":"0"
	},
	"msg":"操作成功"
}
~~~~

##### 更新分类

| 请求方式 | 请求路径          | 是否需求token头 |
| -------- | ----------------- | --------------- |
| PUT      | /content/category | 是              |

请求体：

~~~~json
{
    "description":"是的",
    "id":"3",
    "name":"威威2",
    "status":"0"
}
~~~~

响应格式：

~~~~json
{
	"code":200,
	"msg":"操作成功"
}
~~~~

#### 代码实现

##### 回显分类信息

CategoryController

```java
 @GetMapping("/{id}")
    public ResponseResult getInfoById(@PathVariable("id") Long id){
        return categoryService.getInfoById(id);
    }
```

CategoryServiceImpl

```java
@Override
    public ResponseResult getInfoById(Long id) {
        Category category=getById(id);
        CategoryVo categoryVo=BeanCopyUtils.copyBean(category,CategoryVo.class);
        return ResponseResult.okResult(categoryVo);
    }
```

##### 更新分类

CategoryController

```java
@PutMapping()
    public ResponseResult updateCategory(@RequestBody Category category){
        return categoryService.updateCategory(category);
    }
```

CategoryServiceImpl

```java
 @Override
    public ResponseResult updateCategory(Category category) {
        if (updateById(category)){
            return ResponseResult.okResult();
        }
        return ResponseResult.errorResult(AppHttpCodeEnum.SYSTEM_ERROR,"未知错误，修改失败");
    }
```

### 删除分类

#### 需求

删除某个分类（逻辑删除）

#### 接口设计

| 请求方式 | 请求路径               | 是否需求token头 |
| -------- | ---------------------- | --------------- |
| DELETE   | /content/category/{id} | 是              |

Path请求参数：

id：要删除的分类id

响应格式：

~~~~json
{
	"code":200,
	"msg":"操作成功"
}
~~~~

#### 代码实现(没考虑删除文章表里对应的分类id)

CategoryController

```java
@DeleteMapping("/{id}")
    public ResponseResult deleteById(@PathVariable("id") Long id){
        return categoryService.deleteById(id);
    }
```

CategoryServiceImpl

```java
@Override
    public ResponseResult deleteById(Long id) {
        if (removeById(id)){
            return ResponseResult.okResult();
        }
        return ResponseResult.errorResult(AppHttpCodeEnum.SYSTEM_ERROR,"未知错误，删除失败");
    }
```

### 分页查询友链列表

#### 需求

需要分页查询友链列表。

能根据友链名称进行模糊查询。

能根据状态进行查询。

#### 接口设计

| 请求方式 | 请求路径           | 是否需求token头 |
| -------- | ------------------ | --------------- |
| GET      | /content/link/list | 是              |

Query格式请求参数：

pageNum: 页码

pageSize: 每页条数

name：友链名

status:状态

响应格式：

~~~~json
{
	"code":200,
	"data":{
		"rows":[
			{
				"address":"https://www.baidu.com",
				"description":"sda",
				"id":"1",						       "logo":"https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fn1.itc.cn%2Fimg8%2Fwb%2Frecom%2F2016%2F05%2F10%2F146286696706220328.PNG&refer=http%3A%2F%2Fn1.itc.cn&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1646205529&t=f942665181eb9b0685db7a6f59d59975",
				"name":"sda",
				"status":"0"
			}
		],
		"total":"1"
	},
	"msg":"操作成功"
}
~~~~

#### 代码实现

LinkController

```java
@RestController
@RequestMapping("/content/link")
public class LinkController {
    @Resource
    LinkService linkService;
    @GetMapping("/list")
    public ResponseResult listLink(Integer pageNum,Integer pageSize, String name, String status){
        return linkService.listLink(pageNum,pageSize, name, status);
    }
}
```

LinkServiceImpl

```java
@Override
    public ResponseResult listLink(Integer pageNum, Integer pageSize, String name, String status) {
        //查询条件
        LambdaQueryWrapper<Link> lambdaQueryWrapper = new LambdaQueryWrapper<>();
        // 模糊匹配
        //第一个参数：一个bool表达式，要求前端传来了categoryId并且大于0。如果这个参数为true，就会把对第二，三个参数的判断加到sql语句中
        lambdaQueryWrapper.like(Objects.nonNull(name),Link::getName,name);
        //根据状态查询
        lambdaQueryWrapper.eq(Objects.nonNull(status),Link::getStatus,status);
        //分页查询
        Page<Link> page = new Page<>(pageNum,pageSize);
        page(page,lambdaQueryWrapper);
        //封装查询结果
        List<LinkVo> linkVos = BeanCopyUtils.copyBeanList(page.getRecords(), LinkVo.class);
        PageVo pageVo = new PageVo(linkVos,page.getTotal());
        return ResponseResult.okResult(pageVo);
    }
```

LinkVo添加一个status属性



### 新增友链

#### 需求

需要新增友链功能

#### 接口设计

| 请求方式 | 请求路径      | 是否需求token头 |
| -------- | ------------- | --------------- |
| POST     | /content/link | 是              |

请求体：

~~~~json
{
    "name":"sda",
    "description":"weqw",
    "address":"wewe",
    "logo":"weqe",
    "status":"2"
}
~~~~

响应格式：

~~~~json
{
	"code":200,
	"msg":"操作成功"
}
~~~~

#### 代码实现

LinkController

```java
 @PostMapping()
    public ResponseResult addLink(@RequestBody Link link){
        return linkService.addLink(link);
    }
```

LinkServiceImpl

```java
@Override
    public ResponseResult addLink(Link link) {
        save(link);
        return ResponseResult.okResult();
    }
```

Link字段自动填充

```java
    @TableField(fill = FieldFill.INSERT)
    private Long createBy;
    @TableField(fill = FieldFill.INSERT)
    private Date createTime;
    @TableField(fill = FieldFill.INSERT_UPDATE)
    private Long updateBy;
    @TableField(fill = FieldFill.INSERT_UPDATE)
    private Date updateTime;
```

### 修改友链

#### 需求

需要提供修改友链的功能

#### 接口设计

##### 根据id查询友联

| 请求方式 | 请求路径          | 是否需求token头 |
| -------- | ----------------- | --------------- |
| Get      | content/link/{id} | 是              |

Path格式请求参数：

id: 友链id

响应格式：

~~~~json
{
	"code":200,
	"data":{
		"address":"wewe",
		"description":"weqw",
		"id":"4",
		"logo":"weqe",
		"name":"sda",
		"status":"2"
	},
	"msg":"操作成功"
}
~~~~

##### 修改友链

| 请求方式 | 请求路径      | 是否需求token头 |
| -------- | ------------- | --------------- |
| PUT      | /content/link | 是              |

请求体：

~~~~json
{
    "address":"https://www.qq.com",
    "description":"dada2",
    "id":"2",
    "logo":"https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fn1.itc.cn%2Fimg8%2Fwb%2Frecom%2F2016%2F05%2F10%2F146286696706220328.PNG&refer=http%3A%2F%2Fn1.itc.cn&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1646205529&t=f942665181eb9b0685db7a6f59d59975",
    "name":"sda",
    "status":"0"
}
~~~~

响应格式：

~~~~json
{
	"code":200,
	"msg":"操作成功"
}
~~~~

#### 代码实现

##### 回显友链信息

LinkController

```java
 @GetMapping("/{id}")
    public ResponseResult getInfoById(@PathVariable("id") Long id){
        return linkService.getInfoById(id);
    }
```

LinkServiceImpl

```java
 @Override
    public ResponseResult getInfoById(Long id) {
        LambdaQueryWrapper<Link> lambdaQueryWrapper=new LambdaQueryWrapper<>();
        lambdaQueryWrapper.eq(Link::getId,id);
        Link link=getOne(lambdaQueryWrapper);
        LinkVo linkVo=BeanCopyUtils.copyBean(link,LinkVo.class);
        return ResponseResult.okResult(linkVo);
    }
```

##### 修改友链

LinkController

```java
 @PutMapping()
    public ResponseResult updateLink(@RequestBody Link link){
        return linkService.updateLink(link);
    }
```

LinkServiceImpl

```java
  @Override
    public ResponseResult updateLink(Link link) {
        if (updateById(link)){
            return ResponseResult.okResult();
        }
       return  ResponseResult.errorResult(AppHttpCodeEnum.SYSTEM_ERROR,"未知错误，修改失败");
    }
```

### 删除友链

#### 需求

删除某个友链（逻辑删除）

#### 接口设计

| 请求方式 | 请求路径           | 是否需求token头 |
| -------- | ------------------ | --------------- |
| DELETE   | /content/link/{id} | 是              |

Path请求参数：

id：要删除的友链id

响应格式：

~~~~json
{
	"code":200,
	"msg":"操作成功"
}
~~~~

#### 代码实现

LinkController

```java
  @DeleteMapping("/{id}")
    public ResponseResult deleteById(@PathVariable("id") Long id){
        return linkService.deleteById(id);
    }
```

LinkServiceImpl

```java
   @Override
    public ResponseResult deleteById(Long id) {
        if (removeById(id)){
            return ResponseResult.okResult();
        }
        return ResponseResult.errorResult(AppHttpCodeEnum.SYSTEM_ERROR,"未知错误，删除失败");
    }
```